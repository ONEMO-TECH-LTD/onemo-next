#!/usr/bin/env node
/**
 * build-tokens.mjs — ONEMO Design Token Pipeline
 *
 * Reads the Figma Variables JSON export and generates 4 CSS files:
 *   - src/app/tokens/primitives.css    (Layer 1 — :root)
 *   - src/app/tokens/aliases.css       (Layer 2 — :root)
 *   - src/app/tokens/semantic.css      (Layer 3 — @theme)
 *   - src/app/tokens/semantic-inline.css (Layer 3 — :root + dark + @theme inline)
 *
 * Zero dependencies. Node.js 18+ (uses fs/promises, path, URL).
 *
 * Usage:
 *   node scripts/build-tokens.mjs [path-to-json]
 *
 * Default JSON path:
 *   ../onemo-ssot-global/11-design-system/11.7-figma-variables-baseline-feb16.json
 *
 * Documentation: onemo-ssot-global/11-design-system/11.8-css-pipeline.md
 * Naming rules: onemo-ssot-global/11-design-system/11.5-naming-convention.md
 */

import { readFile, writeFile, mkdir, stat, readdir } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { parse, formatCss, converter } from 'culori';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, '..');
const DEFAULT_JSON = join(ROOT, '../onemo-ssot-global/11-design-system/11.7-figma-variables-baseline-feb16.json');
const DEFAULT_OUTPUT_DIR = join(ROOT, 'src/app/tokens');
const OUTPUT_FILES = ['primitives.css', 'aliases.css', 'semantic.css', 'semantic-inline.css'];

const HEADER = `/* Auto-generated by build-tokens.mjs from Figma Variables Export
   Source: onemo-ssot-global/11-design-system/11.7-figma-variables-baseline-feb16.json
   DO NOT EDIT — regenerate with: node scripts/build-tokens.mjs */\n\n`;

const toOklch = converter('oklch');

// ─── Naming Transform Helpers ────────────────────────────────────────────────

/**
 * Font weight mapping: Figma style name → CSS numeric weight
 */
const FONT_WEIGHT_MAP = {
  'ExtraLight': 200,
  'Extra Light': 200,
  'Light': 300,
  'Regular': 400,
  'Medium': 500,
  'SemiBold': 600,
  'Semi Bold': 600,
  'Bold': 700,
  'ExtraBold': 800,
  'Extra Bold': 800,
  'Black': 900,
  'Regular Italic': 400,
  'Medium Italic': 500,
  'Semi Bold Italic': 600,
  'Bold Italic': 700,
};

/**
 * Font family alias mapping: Figma key → CSS semantic name
 */
const FONT_FAMILY_ALIAS_MAP = {
  'Primary': 'primary',
  'Secondary - Plain': 'display-plain',
  'Secondary - Deco': 'display-deco',
  'Tertiary': 'label',
};

const COLLECTION_NAMES = {
  primitiveColor: ['1.0_Primitive_Colours'],
  primitiveDimensions: ['1.1_Primitive_Dimensions'],
  primitiveType: ['1.2_Primitive_Type'],
  primitiveLegacy: ['_Primitives'],
  aliasColor: ['2.0_Alias_Colours'],
  aliasType: ['2.1_Alias_Type'],
  aliasLegacy: ['_Alias'],
  semanticColors: ['3.0_Semantic_Colours'],
  componentColors: ['4.0_Component_Colours'],
  effects: ['5.0_Effects'],
  utility: ['6.0_Utility'],
  semanticColorsLegacy: ['1. Color modes'],
  semanticType: ['3.1_Semantic_Type'],
  semanticSpacing: ['3.2_Semantic_Spacing'],
  semanticWidth: ['3.3_Semantic_Width'],
  semanticContainers: ['3.4_Semantic_Containers'],
  semanticRadius: ['3.5_Semantic_Radius'],
  semanticTypeLegacy: ['6. Typography'],
  semanticSpacingLegacy: ['3. Spacing'],
  semanticWidthLegacy: ['4. Widths'],
  semanticContainersLegacy: ['5. Containers'],
  semanticRadiusLegacy: ['2. Radius'],
};

/**
 * Transform a key name to CSS-safe kebab-case
 * Steps from 11.5 Section 1.1:
 *  - Lowercase
 *  - Remove parenthetical annotations
 *  - Replace Unicode One Dot Leader (U+2024) with hyphen
 *  - Replace spaces with hyphens
 *  - Collapse multiple hyphens
 *  - Replace underscores with hyphens
 */
function toKebab(str) {
  return str
    .toLowerCase()
    // Normalize accented characters to ASCII (é → e, ü → u, etc.)
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    // Remove parenthetical annotations: "(900)", "(0px)", "(1,024px)", etc.
    .replace(/\s*\([^)]*\)\s*/g, '')
    // Replace Unicode One Dot Leader (U+2024) with hyphen
    .replace(/\u2024/g, '-')
    // Replace spaces with hyphens
    .replace(/\s+/g, '-')
    // Replace underscores with hyphens
    .replace(/_/g, '-')
    // British English spelling
    .replace(/gray/g, 'grey')
    // Collapse multiple hyphens
    .replace(/-{2,}/g, '-')
    // Remove leading/trailing hyphens
    .replace(/^-|-$/g, '');
}

/**
 * Like toKebab but preserves mode annotations in parentheses:
 * "Gray (light mode)" → "gray-light"
 * "Gray (dark mode)" → "gray-dark"
 * "Gray (dark mode alpha)" → "gray-dark-alpha"
 */
function toKebabPreserveMode(str) {
  return str
    .toLowerCase()
    // Transform mode annotations into part of the name
    .replace(/\s*\(([^)]*)\)\s*/g, (match, content) => {
      if (content.includes('light mode') || content.includes('dark mode')) {
        return '-' + content.replace(/\s+mode\b/g, '').trim().replace(/\s+/g, '-');
      }
      return '';
    })
    .replace(/\u2024/g, '-')
    .replace(/\s+/g, '-')
    .replace(/_/g, '-')
    .replace(/gray/g, 'grey')
    .replace(/-{2,}/g, '-')
    .replace(/^-|-$/g, '');
}

/**
 * Convert Figma letter-spacing percentage to em
 * Chrome <145 doesn't support % for letter-spacing
 * Formula: em = figmaPercentValue / 100
 */
function letterSpacingToEm(percentValue) {
  if (percentValue === 0) return '0';
  const em = percentValue / 100;
  // Avoid floating point noise: round to 4 decimal places
  const rounded = Math.round(em * 10000) / 10000;
  return `${rounded}em`;
}

/**
 * Convert px to rem (base 16px)
 */
function pxToRem(px) {
  if (px === 0) return '0px';
  const rem = px / 16;
  // Clean up floating point
  const rounded = Math.round(rem * 10000) / 10000;
  return `${rounded}rem`;
}

function roundNumber(value, decimals) {
  const factor = 10 ** decimals;
  return Math.round((value + Number.EPSILON) * factor) / factor;
}

function formatRounded(value, decimals) {
  const rounded = roundNumber(value, decimals);
  if (Object.is(rounded, -0)) return '0';
  return rounded.toString();
}

function formatColorToOklch(value) {
  const trimmed = String(value).trim();
  if (!trimmed.startsWith('#') && !/^rgba?\(/i.test(trimmed)) {
    return value;
  }

  const parsed = parse(trimmed);
  if (!parsed) {
    return value;
  }

  const converted = toOklch(parsed);
  if (!converted || typeof converted.l !== 'number' || typeof converted.c !== 'number') {
    return formatCss(parsed);
  }

  const lightness = `${formatRounded(converted.l * 100, 2)}%`;
  const chroma = formatRounded(converted.c, 3);
  const hue = formatRounded(Number.isFinite(converted.h) ? converted.h : 0, 2);
  const alpha = typeof converted.alpha === 'number' ? converted.alpha : 1;

  if (alpha < 1) {
    return `oklch(${lightness} ${chroma} ${hue} / ${formatRounded(alpha * 100, 2)}%)`;
  }

  return `oklch(${lightness} ${chroma} ${hue})`;
}

// ─── JSON Parsing & Reference Resolution ─────────────────────────────────────

/**
 * Parse the JSON array into a Map of collection name → collection data
 */
function parseCollections(json) {
  const collections = new Map();
  for (const entry of json) {
    const collectionName = Object.keys(entry)[0];
    collections.set(collectionName, entry[collectionName]);
  }
  return collections;
}

function findCollection(collections, candidateNames) {
  for (const name of candidateNames) {
    if (collections.has(name)) {
      return { name, collection: collections.get(name) };
    }
  }
  return null;
}

function requireCollection(collections, candidateNames, label) {
  const result = findCollection(collections, candidateNames);
  if (!result) {
    throw new Error(`Missing collection for ${label}. Tried: ${candidateNames.join(', ')}`);
  }
  return result;
}

function hasAnyCollection(collections, candidateNames) {
  return candidateNames.some(name => collections.has(name));
}

function getModeData(collection, preferredNames = []) {
  const modes = collection?.modes;
  if (!modes || typeof modes !== 'object') {
    throw new Error('Collection has no modes');
  }

  for (const name of preferredNames) {
    if (modes[name]) return modes[name];
  }

  const firstMode = Object.values(modes)[0];
  if (!firstMode) {
    throw new Error('Collection modes are empty');
  }
  return firstMode;
}

function getLightDarkModes(collection) {
  const entries = Object.entries(collection?.modes || {});
  const light = entries.find(([modeName]) => /light/i.test(modeName));
  const dark = entries.find(([modeName]) => /dark/i.test(modeName));

  if (!light || !dark) return null;

  return {
    lightName: light[0],
    darkName: dark[0],
    lightMode: light[1],
    darkMode: dark[1],
  };
}

function prependCategory(path, category) {
  if (!category || path[0] === category) {
    return path;
  }
  return [category, ...path];
}

function isSemanticColorCollectionName(collectionName) {
  return [
    ...COLLECTION_NAMES.semanticColors,
    ...COLLECTION_NAMES.componentColors,
    ...COLLECTION_NAMES.effects,
    ...COLLECTION_NAMES.utility,
    ...COLLECTION_NAMES.semanticColorsLegacy,
  ].includes(collectionName);
}

function isAliasCollectionName(collectionName) {
  return [
    ...COLLECTION_NAMES.aliasColor,
    ...COLLECTION_NAMES.aliasType,
    ...COLLECTION_NAMES.aliasLegacy,
  ].includes(collectionName);
}

function isPrimitiveCollectionName(collectionName) {
  return [
    ...COLLECTION_NAMES.primitiveColor,
    ...COLLECTION_NAMES.primitiveDimensions,
    ...COLLECTION_NAMES.primitiveType,
    ...COLLECTION_NAMES.primitiveLegacy,
  ].includes(collectionName);
}

function getCollectionForReference(collections, collectionName, refPath) {
  if (collectionName && collections.has(collectionName)) {
    return collections.get(collectionName);
  }

  const root = refPath.split('.')[0];

  if (collectionName === '_Primitives') {
    if (root === 'Colors') return findCollection(collections, [...COLLECTION_NAMES.primitiveColor, ...COLLECTION_NAMES.primitiveLegacy])?.collection;
    if (root === 'Dimensions') return findCollection(collections, [...COLLECTION_NAMES.primitiveDimensions, ...COLLECTION_NAMES.primitiveLegacy])?.collection;
    if (root === 'Typography') return findCollection(collections, [...COLLECTION_NAMES.primitiveType, ...COLLECTION_NAMES.primitiveLegacy])?.collection;
  }

  if (collectionName === '_Alias') {
    if (root === 'Colors') return findCollection(collections, [...COLLECTION_NAMES.aliasColor, ...COLLECTION_NAMES.aliasLegacy])?.collection;
    if (root === 'Typography') return findCollection(collections, [...COLLECTION_NAMES.aliasType, ...COLLECTION_NAMES.aliasLegacy])?.collection;
  }

  if (collectionName === '1. Color modes') {
    return findCollection(collections, [...COLLECTION_NAMES.semanticColors, ...COLLECTION_NAMES.semanticColorsLegacy])?.collection;
  }

  return null;
}

function getSemanticColorCollections(collections) {
  const collectionsToUse = [];

  const baseSemantic = findCollection(collections, [...COLLECTION_NAMES.semanticColors, ...COLLECTION_NAMES.semanticColorsLegacy]);
  if (baseSemantic) collectionsToUse.push(baseSemantic);

  for (const names of [COLLECTION_NAMES.componentColors, COLLECTION_NAMES.effects, COLLECTION_NAMES.utility]) {
    const found = findCollection(collections, names);
    if (found) collectionsToUse.push(found);
  }

  return collectionsToUse;
}

/**
 * Walk a dot-separated path through a nested object
 * Handles Figma's path format: "Colors.Neutral.Gray (light mode).900"
 * Keys can contain dots — but in practice the Figma plugin uses dots as path separators
 */
function walkPath(obj, pathStr) {
  // Split by dots, but we need to handle keys that might contain dots
  // In the Figma export, path segments match JSON keys exactly
  const segments = pathStr.split('.');
  let current = obj;

  for (const seg of segments) {
    if (!current || typeof current !== 'object') return undefined;
    if (seg in current) {
      current = current[seg];
    } else {
      // Try progressively joining segments for keys with dots
      return undefined;
    }
  }
  return current;
}

/**
 * Resolve a reference value to its final literal value
 * References look like: "{Colors.Neutral.Gray (light mode).900}"
 * The $collectionName tells us which collection to look in
 */
function resolveReference(value, collectionName, collections, depth = 0) {
  if (depth > 5) {
    console.warn(`Max reference depth exceeded for: ${value}`);
    return value;
  }

  // Literal value (not a reference)
  if (typeof value !== 'string' || !value.startsWith('{') || !value.endsWith('}')) {
    return value;
  }

  const path = value.slice(1, -1); // Remove { and }
  const targetCollection = getCollectionForReference(collections, collectionName, path);

  if (!targetCollection) {
    console.warn(`Collection not found: ${collectionName} for ref ${value}`);
    return value;
  }

  // Walk through the collection's modes to find the value
  // Most collections have a single mode, but Color modes has Light/Dark
  const modes = targetCollection.modes;
  for (const modeName of Object.keys(modes)) {
    const result = walkPath(modes[modeName], path);
    if (result && result.$value !== undefined) {
      // If this is also a reference, resolve recursively
      const nextCollection = result.$collectionName || collectionName;
      return resolveReference(result.$value, nextCollection, collections, depth + 1);
    }
  }

  console.warn(`Could not resolve reference: ${value} in collection ${collectionName}`);
  return value;
}

/**
 * Flatten a nested object tree into an array of { path: [...], node: {...} } entries
 * Stops at leaf nodes (objects with $value)
 */
function flattenTree(obj, pathSoFar = []) {
  const results = [];

  for (const [key, val] of Object.entries(obj)) {
    if (key.startsWith('$')) continue; // Skip metadata keys

    if (val && typeof val === 'object' && '$value' in val) {
      // Leaf node
      results.push({ path: [...pathSoFar, key], node: val });
    } else if (val && typeof val === 'object') {
      // Branch — recurse
      results.push(...flattenTree(val, [...pathSoFar, key]));
    }
  }

  return results;
}

// ─── CSS Generation: Primitives ──────────────────────────────────────────────

function generatePrimitivesCSS(collections) {
  const entries = [];
  const hasSplitPrimitives = hasAnyCollection(collections, [
    ...COLLECTION_NAMES.primitiveColor,
    ...COLLECTION_NAMES.primitiveDimensions,
    ...COLLECTION_NAMES.primitiveType,
  ]);

  if (hasSplitPrimitives) {
    const primitiveSources = [
      {
        info: requireCollection(
          collections,
          [...COLLECTION_NAMES.primitiveColor, ...COLLECTION_NAMES.primitiveLegacy],
          'Primitive colours',
        ),
        category: 'Colors',
      },
      {
        info: requireCollection(
          collections,
          [...COLLECTION_NAMES.primitiveDimensions, ...COLLECTION_NAMES.primitiveLegacy],
          'Primitive dimensions',
        ),
        category: 'Dimensions',
      },
      {
        info: requireCollection(
          collections,
          [...COLLECTION_NAMES.primitiveType, ...COLLECTION_NAMES.primitiveLegacy],
          'Primitive type',
        ),
        category: 'Typography',
      },
    ];

    for (const { info, category } of primitiveSources) {
      const modeData = getModeData(info.collection, ['Core', 'Value', 'Mode 1']);
      for (const entry of flattenTree(modeData)) {
        entries.push({ ...entry, path: prependCategory(entry.path, category) });
      }
    }
  } else {
    const primitives = requireCollection(collections, COLLECTION_NAMES.primitiveLegacy, 'Legacy primitives');
    const modeData = getModeData(primitives.collection, ['Core', 'Value', 'Mode 1']);
    entries.push(...flattenTree(modeData));
  }

  const lines = [HEADER, ':root {\n'];
  let count = 0;
  let currentCategory = '';

  for (const { path, node } of entries) {
    const category = path[0];
    if (category !== currentCategory) {
      if (currentCategory) lines.push('\n');
      lines.push(`  /* ═══ ${path.slice(0, Math.min(2, path.length)).join(' > ')} ═══ */\n`);
      currentCategory = category;
    }

    const propName = buildPrimitiveName(path);
    const cssValue = formatPrimitiveValue(path, node);

    lines.push(`  ${propName}: ${cssValue};\n`);
    count++;
  }

  lines.push('}\n');
  return { css: lines.join(''), count };
}

function buildPrimitiveName(path) {
  // Special handling for different primitive categories
  const category = path[0];

  if (category === 'Colors') {
    // Colors/Base/white → --primitive-color-base-white
    // Colors/Neutral/Gray (light mode)/500 → --primitive-color-gray-light-500
    // Colors/Neutral/Gray (dark mode)/500 → --primitive-color-gray-dark-500
    // Colors/Neutral/Gray (dark mode alpha)/500 → --primitive-color-gray-dark-alpha-500
    // Colors/ONEMO - UI Palette/Dusty/Blue Green/500 → --primitive-color-blue-green-500
    const parts = path.slice(1); // Remove "Colors"

    // Skip "ONEMO - UI Palette", "Dusty", and "Neutral" intermediate groups
    const filtered = parts.filter(p =>
      p !== 'ONEMO - UI Palette' && p !== 'Dusty' && p !== 'Neutral'
    );

    // Use toKebabPreserveMode for gray names to preserve light/dark distinction
    return `--primitive-color-${filtered.map(p => toKebabPreserveMode(p)).join('-')}`;
  }

  if (category === 'Dimensions') {
    // Dimensions/4 (16px) → --primitive-dimension-4
    const dimName = toKebab(path[1]);
    return `--primitive-dimension-${dimName}`;
  }

  if (category === 'Typography') {
    const subCategory = path[1];

    if (subCategory === 'Type Scale') {
      // Typography/Type Scale/72 → --primitive-type-scale-72
      return `--primitive-type-scale-${path[2]}`;
    }

    if (subCategory === 'Letter Spacing') {
      // Typography/Letter Spacing/+10 → --primitive-letter-spacing-pos-10
      // Typography/Letter Spacing/-10 → --primitive-letter-spacing-neg-10
      // Typography/Letter Spacing/zero → --primitive-letter-spacing-0
      const rawName = path[2];
      if (rawName === 'zero') return '--primitive-letter-spacing-0';
      if (rawName.startsWith('+')) return `--primitive-letter-spacing-pos-${rawName.slice(1)}`;
      if (rawName.startsWith('-')) return `--primitive-letter-spacing-neg-${rawName.slice(1)}`;
      return `--primitive-letter-spacing-${rawName}`;
    }

    if (subCategory === 'Font Family') {
      // Typography/Font Family/Basic/Satoshi → --primitive-font-satoshi
      // Typography/Font Family/Decorative/Electric Blue → --primitive-font-electric-blue
      const fontName = path[path.length - 1];
      return `--primitive-font-${toKebab(fontName)}`;
    }

    if (subCategory === 'Paragraph Spacing') {
      return `--primitive-paragraph-spacing-${toKebab(path[2])}`;
    }
  }

  // Fallback
  return `--primitive-${path.map(p => toKebab(p)).join('-')}`;
}

function formatPrimitiveValue(path, node) {
  const category = path[0];
  const value = node.$value;

  if (category === 'Colors') {
    // Primitive colors are exported in OKLCH.
    return formatColorToOklch(value);
  }

  if (category === 'Dimensions') {
    // Dimensions in px → convert to rem (except 0)
    if (typeof value === 'number') {
      return value === 0 ? '0px' : pxToRem(value);
    }
    return `${value}`;
  }

  if (category === 'Typography') {
    const subCategory = path[1];

    if (subCategory === 'Type Scale') {
      // Type scale values are px → convert to rem
      return typeof value === 'number' ? pxToRem(value) : `${value}`;
    }

    if (subCategory === 'Letter Spacing') {
      // Letter spacing: Figma stores as percentage number → convert to em
      return typeof value === 'number' ? letterSpacingToEm(value) : `${value}`;
    }

    if (subCategory === 'Font Family') {
      // Font family: wrap in quotes, add appropriate generic fallback
      const fontName = String(value);
      const generic = fontName.toLowerCase().includes('mono') ? 'monospace' : 'sans-serif';
      return `"${fontName}", ${generic}`;
    }

    if (subCategory === 'Paragraph Spacing') {
      // Paragraph spacing: output as px
      return typeof value === 'number' ? `${value}px` : `${value}`;
    }
  }

  return `${value}`;
}

// ─── CSS Generation: Aliases ─────────────────────────────────────────────────

function generateAliasesCSS(collections) {
  let typography;
  let colors;

  const hasSplitAliases = hasAnyCollection(collections, [
    ...COLLECTION_NAMES.aliasColor,
    ...COLLECTION_NAMES.aliasType,
  ]);

  if (hasSplitAliases) {
    const aliasType = requireCollection(collections, COLLECTION_NAMES.aliasType, 'Alias type');
    const aliasTypeMode = getModeData(aliasType.collection, ['Style', 'Value', 'Mode 1']);
    typography = aliasTypeMode.Typography || aliasTypeMode;

    const aliasColor = requireCollection(collections, COLLECTION_NAMES.aliasColor, 'Alias colours');
    const aliasColorMode = getModeData(aliasColor.collection, ['Style', 'Value', 'Mode 1']);
    colors = aliasColorMode.Colors || aliasColorMode;
  } else {
    const alias = requireCollection(collections, COLLECTION_NAMES.aliasLegacy, 'Legacy alias');
    const modeData = getModeData(alias.collection, ['Style', 'Value', 'Mode 1']);
    typography = modeData.Typography || modeData;
    colors = modeData.Colors;
  }

  const lines = [HEADER, ':root {\n'];
  let count = 0;

  if (!typography) {
    throw new Error('Alias typography tokens not found');
  }

  // Font Families (4)
  lines.push('  /* ═══ Typography: Font Families ═══ */\n');
  const fontFamilies = typography['Font-Family'];
  for (const [key, node] of Object.entries(fontFamilies)) {
    if (key.startsWith('$')) continue;
    const semanticName = FONT_FAMILY_ALIAS_MAP[key];
    if (!semanticName) {
      console.warn(`Unknown font family alias: ${key}`);
      continue;
    }
    // Resolve to primitive font name
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const primitivePropName = `--primitive-font-${toKebab(resolvedValue)}`;
    lines.push(`  --alias-font-${semanticName}: var(${primitivePropName});\n`);
    count++;
  }

  // Font Styles (weights) — direct values, not references
  lines.push('\n  /* ═══ Typography: Font Styles (weights) ═══ */\n');
  const fontStyles = typography['Font-Style'];
  for (const [category, group] of Object.entries(fontStyles)) {
    if (category.startsWith('$')) continue;
    for (const [name, node] of Object.entries(group)) {
      if (name.startsWith('$')) continue;
      const weight = FONT_WEIGHT_MAP[node.$value] || 400;
      const cssName = toKebab(node.$value);
      lines.push(`  --alias-font-style-${cssName}: ${weight};\n`);
      count++;
    }
  }

  // Font Sizes (14)
  lines.push('\n  /* ═══ Typography: Font Sizes ═══ */\n');
  const fontSizes = typography['Font-Size'];
  for (const [group, sizes] of Object.entries(fontSizes)) {
    if (group.startsWith('$')) continue;
    for (const [size, node] of Object.entries(sizes)) {
      if (size.startsWith('$')) continue;
      const resolvedPx = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
      const primitiveProp = `--primitive-type-scale-${resolvedPx}`;
      lines.push(`  --alias-font-size-${toKebab(group)}-${toKebab(size)}: var(${primitiveProp});\n`);
      count++;
    }
  }

  // Line Heights (14)
  lines.push('\n  /* ═══ Typography: Line Heights ═══ */\n');
  const lineHeights = typography['Line-Height'];
  for (const [group, sizes] of Object.entries(lineHeights)) {
    if (group.startsWith('$')) continue;
    for (const [size, node] of Object.entries(sizes)) {
      if (size.startsWith('$')) continue;
      const resolvedPx = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
      const primitiveProp = `--primitive-type-scale-${resolvedPx}`;
      lines.push(`  --alias-line-height-${toKebab(group)}-${toKebab(size)}: var(${primitiveProp});\n`);
      count++;
    }
  }

  // Letter Spacing (13)
  lines.push('\n  /* ═══ Typography: Letter Spacing ═══ */\n');
  const letterSpacing = typography['Letter-Spacing'];
  for (const [name, node] of Object.entries(letterSpacing)) {
    if (name.startsWith('$')) continue;
    // Names like "LeSp+10", "LeS+4", "LeS-0 - default"
    // Resolve to primitive reference
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    // Determine sign from the primitive value
    let primitiveProp;
    if (typeof resolvedValue === 'number') {
      if (resolvedValue === 0) primitiveProp = '--primitive-letter-spacing-0';
      else if (resolvedValue > 0) primitiveProp = `--primitive-letter-spacing-pos-${Math.round(resolvedValue * 10)}`;
      else primitiveProp = `--primitive-letter-spacing-neg-${Math.abs(Math.round(resolvedValue * 10))}`;
    } else {
      primitiveProp = `--primitive-letter-spacing-0`;
    }

    // Determine alias name from Figma key
    let aliasName;
    if (name.includes('-0') || name.includes('default')) {
      aliasName = '0';
    } else {
      // Extract sign and number from names like "LeSp+10", "LeS+4", "LeS-8"
      const match = name.match(/([+-])(\d+)/);
      if (match) {
        aliasName = match[1] === '+' ? `pos-${match[2]}` : `neg-${match[2]}`;
      } else {
        aliasName = toKebab(name);
      }
    }

    lines.push(`  --alias-letter-spacing-${aliasName}: var(${primitiveProp});\n`);
    count++;
  }

  // Paragraph Spacing — excluded from CSS output (comment only)
  lines.push('\n  /* ═══ Typography: Paragraph Spacing — NOT output to CSS ═══ */\n');
  lines.push('  /* Paragraph spacing is handled by component margins, not custom properties */\n');

  // Colors
  if (colors) {
    lines.push('\n  /* ═══ Colors ═══ */\n');
    const colorEntries = flattenTree(colors);
    for (const { path, node } of colorEntries) {
      // path: ["Brand", "500"] or ["System", "Error", "500"]
      let cssName;
      if (path[0] === 'Brand') {
        cssName = `--alias-brand-${path.slice(1).map(p => toKebab(p)).join('-')}`;
      } else if (path[0] === 'System') {
        // System/Error/500 → --alias-error-500
        cssName = `--alias-${path.slice(1).map(p => toKebab(p)).join('-')}`;
      } else {
        cssName = `--alias-color-${path.map(p => toKebab(p)).join('-')}`;
      }

      // Resolve to primitive var() reference
      const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
      // Build primitive property name from resolved path
      let primitiveRef;
      if (typeof node.$value === 'string' && node.$value.startsWith('{')) {
        // It's a reference — build var() from the reference path
        const refPath = node.$value.slice(1, -1); // e.g. "Colors.ONEMO - UI Palette.Dusty.Blue Green.500"
        primitiveRef = buildPrimitiveRefFromPath(refPath);
      } else {
        primitiveRef = resolvedValue;
      }

      lines.push(`  ${cssName}: var(${primitiveRef});\n`);
      count++;
    }
  }

  lines.push('}\n');
  return { css: lines.join(''), count };
}

/**
 * Build a primitive CSS variable name from a Figma reference path
 * e.g. "Colors.ONEMO - UI Palette.Dusty.Blue Green.500" → "--primitive-color-blue-green-500"
 */
function buildPrimitiveRefFromPath(refPath) {
  const parts = refPath.split('.');

  if (parts[0] === 'Colors') {
    // Filter out intermediate groups, including "Neutral"
    const filtered = parts.slice(1).filter(p =>
      p !== 'ONEMO - UI Palette' && p !== 'Dusty' && p !== 'Neutral'
    );
    // Use toKebabPreserveMode to preserve Gray light/dark distinction
    return `--primitive-color-${filtered.map(p => toKebabPreserveMode(p)).join('-')}`;
  }

  if (parts[0] === 'Dimensions') {
    return `--primitive-dimension-${toKebab(parts[1])}`;
  }

  if (parts[0] === 'Typography') {
    if (parts[1] === 'Type Scale') return `--primitive-type-scale-${parts[2]}`;
    if (parts[1] === 'Font Family') return `--primitive-font-${toKebab(parts[parts.length - 1])}`;
    if (parts[1] === 'Letter Spacing') {
      const rawName = parts[2];
      if (rawName === 'zero') return '--primitive-letter-spacing-0';
      if (rawName.startsWith('+')) return `--primitive-letter-spacing-pos-${rawName.slice(1)}`;
      if (rawName.startsWith('-')) return `--primitive-letter-spacing-neg-${rawName.slice(1)}`;
    }
  }

  // Fallback
  return `--primitive-${parts.map(p => toKebab(p)).join('-')}`;
}

// ─── CSS Generation: Semantic (mode-independent) ────────────────────────────

function generateSemanticCSS(collections) {
  const lines = [HEADER, '@theme {\n'];
  let count = 0;

  // Font Families (4)
  lines.push('  /* ═══ Font Families ═══ */\n');
  for (const name of Object.values(FONT_FAMILY_ALIAS_MAP)) {
    lines.push(`  --font-${name}: var(--alias-font-${name});\n`);
    count++;
  }

  // Spacing (17)
  lines.push('\n  /* ═══ Spacing ═══ */\n');
  const spacing = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticSpacing, ...COLLECTION_NAMES.semanticSpacingLegacy],
    'Semantic spacing',
  );
  const spacingMode = getModeData(spacing.collection, ['Mode 1', 'Value', 'Style']);
  for (const [key, node] of Object.entries(spacingMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const cssValue = typeof resolvedValue === 'number'
      ? (resolvedValue === 0 ? '0px' : pxToRem(resolvedValue))
      : `${resolvedValue}`;
    lines.push(`  --${key}: ${cssValue};\n`);
    count++;
  }

  // Radius (11)
  lines.push('\n  /* ═══ Radius ═══ */\n');
  const radius = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticRadius, ...COLLECTION_NAMES.semanticRadiusLegacy],
    'Semantic radius',
  );
  const radiusMode = getModeData(radius.collection, ['Mode 1', 'Value', 'Style']);
  for (const [key, node] of Object.entries(radiusMode)) {
    if (key.startsWith('$')) continue;
    const value = node.$value;
    // Radius stays in px (per 11.8 decision)
    const cssValue = typeof value === 'number' ? `${value}px` : `${value}`;
    lines.push(`  --${key}: ${cssValue};\n`);
    count++;
  }

  // Breakpoints (derived from widths)
  lines.push('\n  /* ═══ Breakpoints ═══ */\n');
  const breakpointMap = {
    sm: 480, md: 640, lg: 768,
    xl: 1024, '2xl': 1280, '3xl': 1440,
  };
  for (const [name, value] of Object.entries(breakpointMap)) {
    lines.push(`  --breakpoint-${name}: ${value}px;\n`);
    count++;
  }

  // Typography Composites (26 presets × 4 sub-properties each)
  lines.push('\n  /* ═══ Typography Composites ═══ */\n');
  const typoCount = generateTypographyComposites(collections, lines);
  count += typoCount;

  lines.push('}\n\n');
  lines.push('@theme inline {\n');

  // Widths (12) — dedicated width namespace
  lines.push('  /* ═══ Widths ═══ */\n');
  const widths = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticWidth, ...COLLECTION_NAMES.semanticWidthLegacy],
    'Semantic width',
  );
  const widthsMode = getModeData(widths.collection, ['Mode 1', 'Value', 'Style']);
  for (const [key, node] of Object.entries(widthsMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const pxValue = typeof resolvedValue === 'number' ? resolvedValue : parseInt(resolvedValue, 10);
    // Widths stay in px (viewport-relative)
    lines.push(`  --width-${key.replace(/^width-/, '')}: ${pxValue}px;\n`);
    count++;
  }

  // Containers (3) — dedicated container namespace
  lines.push('\n  /* ═══ Containers ═══ */\n');
  const containers = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticContainers, ...COLLECTION_NAMES.semanticContainersLegacy],
    'Semantic containers',
  );
  const containersMode = getModeData(containers.collection, ['Value', 'Mode 1', 'Style']);
  for (const [key, node] of Object.entries(containersMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const pxValue = typeof resolvedValue === 'number' ? resolvedValue : parseInt(resolvedValue, 10);
    // Container padding → rem, max-width → px
    if (key.includes('padding')) {
      lines.push(`  --container-${key.replace(/^container-/, '')}: ${pxToRem(pxValue)};\n`);
    } else {
      lines.push(`  --container-${key.replace(/^container-/, '')}: ${pxValue}px;\n`);
    }
    count++;
  }

  lines.push('}\n');
  return { css: lines.join(''), count };
}

/**
 * Generate typography composite CSS from the 6. Typography collection
 * Returns count of tokens generated
 */
function generateTypographyComposites(collections, lines) {
  const typography = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticType, ...COLLECTION_NAMES.semanticTypeLegacy],
    'Semantic typography',
  );
  const modeData = getModeData(typography.collection, ['Value', 'Mode 1', 'Style']);
  let count = 0;

  // Walk the typography tree: Category / Variant / Size / Property
  for (const [category, variants] of Object.entries(modeData)) {
    if (category.startsWith('$')) continue;

    for (const [variant, sizes] of Object.entries(variants)) {
      if (variant.startsWith('$')) continue;

      // Check if this level has properties directly (e.g., Title/Headline has no Size sublevel)
      if (sizes.Font || sizes.Style || sizes.Size) {
        // Direct preset (no size sublevel) — e.g., Title/Headline
        const preset = sizes;
        const presetName = `${toKebab(category)}-${toKebab(variant)}`;
        count += emitPreset(presetName, preset, category, variant, null, collections, lines);
        continue;
      }

      for (const [size, preset] of Object.entries(sizes)) {
        if (size.startsWith('$')) continue;

        if (!preset.Font && !preset.Style && !preset.Size) {
          // Still nested — one more level (e.g., Display/Brand Deco/2XL)
          // This shouldn't happen based on the data, but handle it
          continue;
        }

        const presetName = `${toKebab(category)}-${toKebab(variant)}-${toKebab(size)}`;
        count += emitPreset(presetName, preset, category, variant, size, collections, lines);
      }
    }
  }

  return count;
}

function emitPreset(presetName, preset, category, variant, size, collections, lines) {
  let count = 0;

  // Resolve Size → font-size in rem
  if (preset.Size) {
    const sizeVal = resolveReference(preset.Size.$value, preset.Size.$collectionName || '_Alias', collections);
    const sizeRem = typeof sizeVal === 'number' ? pxToRem(sizeVal) : sizeVal;
    lines.push(`  --text-${presetName}: ${sizeRem};\n`);
    count++;
  }

  // Resolve Line → line-height in rem
  if (preset.Line) {
    const lineVal = resolveReference(preset.Line.$value, preset.Line.$collectionName || '_Alias', collections);
    const lineRem = typeof lineVal === 'number' ? pxToRem(lineVal) : lineVal;
    lines.push(`  --text-${presetName}--line-height: ${lineRem};\n`);
    count++;
  }

  // Resolve Letter → letter-spacing in em
  if (preset.Letter) {
    const letterVal = resolveReference(preset.Letter.$value, preset.Letter.$collectionName || '_Alias', collections);
    const letterEm = typeof letterVal === 'number' ? letterSpacingToEm(letterVal) : letterVal;
    lines.push(`  --text-${presetName}--letter-spacing: ${letterEm};\n`);
    count++;
  }

  // Resolve Style → font-weight
  if (preset.Style) {
    const styleVal = resolveReference(preset.Style.$value, preset.Style.$collectionName || '_Alias', collections);
    const weight = FONT_WEIGHT_MAP[styleVal] || 400;
    lines.push(`  --text-${presetName}--font-weight: ${weight};\n`);
    count++;
  }

  lines.push('\n');
  return count;
}

// ─── CSS Generation: Semantic Inline (mode-dependent colors) ────────────────

function collectSemanticColorEntries(collections) {
  const lightTokens = new Map();
  const darkTokens = new Map();

  for (const collectionInfo of getSemanticColorCollections(collections)) {
    const modePair = getLightDarkModes(collectionInfo.collection);
    if (!modePair) continue;

    for (const entry of flattenTree(modePair.lightMode)) {
      const semanticName = buildSemanticColorName(entry.path);
      lightTokens.set(semanticName, { ...entry, sourceCollection: collectionInfo.name });
    }

    for (const entry of flattenTree(modePair.darkMode)) {
      const semanticName = buildSemanticColorName(entry.path);
      darkTokens.set(semanticName, { ...entry, sourceCollection: collectionInfo.name });
    }
  }

  return { lightTokens, darkTokens };
}

function generateSemanticInlineCSS(collections) {
  const { lightTokens, darkTokens } = collectSemanticColorEntries(collections);

  const lines = [HEADER];
  let count = 0;

  // Section 1: Light mode defaults in :root
  lines.push('/* ═══ Light mode defaults ═══ */\n:root {\n');

  for (const [semanticName, entry] of lightTokens) {
    const cssRef = buildColorValueRef(entry.node, collections);
    lines.push(`  --semantic-${semanticName}: ${cssRef};\n`);
    count++;
  }

  lines.push('}\n\n');

  // Section 2: Dark mode overrides
  lines.push('/* ═══ Dark mode overrides ═══ */\n[data-theme="dark"] {\n');

  for (const [semanticName, lightEntry] of lightTokens) {
    const darkEntry = darkTokens.get(semanticName) || lightEntry;
    const cssRef = buildColorValueRef(darkEntry.node, collections);
    lines.push(`  --semantic-${semanticName}: ${cssRef};\n`);
  }

  lines.push('}\n\n');

  // Section 3: Register for Tailwind utilities
  lines.push('/* ═══ Tailwind theme registration ═══ */\n@theme inline {\n');

  for (const semanticName of lightTokens.keys()) {
    lines.push(`  --color-${semanticName}: var(--semantic-${semanticName});\n`);
  }

  lines.push('}\n');

  return { css: lines.join(''), count };
}

/**
 * Build semantic color name from path
 * e.g. ["Colors", "Text", "text-primary (900)"] → "text-primary"
 * e.g. ["Colors", "Background", "bg-primary_hover"] → "bg-primary-hover"
 * e.g. ["Component colors", "Alpha", "alpha-white-50"] → "alpha-white-50"
 */
function buildSemanticColorName(path) {
  // The last segment is the actual token name
  const tokenName = path[path.length - 1];
  return toKebab(tokenName);
}

/**
 * Build a CSS var() reference for a color mode token value
 */
function buildColorValueRef(node, collections) {
  const value = node.$value;

  // Literal value (rgba, hex)
  if (typeof value !== 'string' || !value.startsWith('{')) {
    return value;
  }

  const collectionName = node.$collectionName;
  const refPath = value.slice(1, -1);

  // Self-reference within semantic color collections
  if (isSemanticColorCollectionName(collectionName)) {
    // Reference to another semantic token — output as var(--semantic-*)
    const parts = refPath.split('.');
    const tokenName = parts[parts.length - 1];
    return `var(--semantic-${toKebab(tokenName)})`;
  }

  // Reference to alias collections
  if (isAliasCollectionName(collectionName)) {
    const refProp = buildAliasRefFromPath(refPath);
    return `var(${refProp})`;
  }

  // Reference to primitive collections
  if (isPrimitiveCollectionName(collectionName)) {
    const refProp = buildPrimitiveRefFromPath(refPath);
    return `var(${refProp})`;
  }

  // Fallback: resolve to literal
  const resolved = resolveReference(value, collectionName, collections);
  return typeof resolved === 'string' ? resolved : `${resolved}`;
}

/**
 * Build an alias CSS variable name from a reference path
 * e.g. "Colors.Brand.200" → "--alias-brand-200"
 * e.g. "Colors.System.Error.500" → "--alias-error-500"
 */
function buildAliasRefFromPath(refPath) {
  const parts = refPath.split('.');

  if (parts[0] === 'Colors') {
    if (parts[1] === 'Brand') {
      return `--alias-brand-${parts.slice(2).map(p => toKebab(p)).join('-')}`;
    }
    if (parts[1] === 'System') {
      return `--alias-${parts.slice(2).map(p => toKebab(p)).join('-')}`;
    }
  }

  // Typography aliases
  if (parts[0] === 'Typography') {
    if (parts[1] === 'Font-Family') {
      const key = parts[2];
      const name = FONT_FAMILY_ALIAS_MAP[key];
      return name ? `--alias-font-${name}` : `--alias-font-${toKebab(key)}`;
    }
  }

  return `--alias-${parts.map(p => toKebab(p)).join('-')}`;
}

// ─── Token Reference Generator ──────────────────────────────────────────────

function generateTokenReference(collections) {
  const lines = [
    '# 11.9 Token Reference\n\n',
    '> Machine-readable token listing for AI agents. Prevents hard-coding hex values.\n',
    '> Auto-generated by `node scripts/build-tokens.mjs`.\n\n',
    '**DO NOT EDIT** — regenerate from the Figma JSON export.\n\n',
    '---\n\n',
  ];

  // Spacing tokens
  lines.push('## Spacing Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Value |\n');
  lines.push('|---|---|---|\n');
  const spacing = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticSpacing, ...COLLECTION_NAMES.semanticSpacingLegacy],
    'Semantic spacing',
  );
  const spacingMode = getModeData(spacing.collection, ['Mode 1', 'Value', 'Style']);
  for (const [key, node] of Object.entries(spacingMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const cssValue = typeof resolvedValue === 'number'
      ? (resolvedValue === 0 ? '0px' : pxToRem(resolvedValue))
      : `${resolvedValue}`;
    lines.push(`| \`--${key}\` | \`p-${key.replace('spacing-', '')}\`, \`m-${key.replace('spacing-', '')}\`, \`gap-${key.replace('spacing-', '')}\` | \`${cssValue}\` |\n`);
  }

  // Radius tokens
  lines.push('\n## Radius Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Value |\n');
  lines.push('|---|---|---|\n');
  const radius = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticRadius, ...COLLECTION_NAMES.semanticRadiusLegacy],
    'Semantic radius',
  );
  const radiusMode = getModeData(radius.collection, ['Mode 1', 'Value', 'Style']);
  for (const [key, node] of Object.entries(radiusMode)) {
    if (key.startsWith('$')) continue;
    lines.push(`| \`--${key}\` | \`rounded-${key.replace('radius-', '')}\` | \`${node.$value}px\` |\n`);
  }

  // Font slots
  lines.push('\n## Font Family Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Font |\n');
  lines.push('|---|---|---|\n');
  for (const [alias, name] of Object.entries(FONT_FAMILY_ALIAS_MAP)) {
    lines.push(`| \`--font-${name}\` | \`font-${name}\` | ${alias} |\n`);
  }

  // Color tokens (semantic)
  lines.push('\n## Color Tokens (Semantic)\n\n');
  lines.push('Use these — never hard-code hex values.\n\n');
  lines.push('| CSS Property | Tailwind Class | Category |\n');
  lines.push('|---|---|---|\n');

  const { lightTokens } = collectSemanticColorEntries(collections);
  for (const [name, entry] of lightTokens) {
    const { path } = entry;
    const category = path.length > 1 ? path[1] || path[0] : path[0];
    // Determine which Tailwind prefix applies
    let twClass;
    if (name.startsWith('text-')) twClass = `text-${name}`;
    else if (name.startsWith('bg-')) twClass = `bg-${name}`;
    else if (name.startsWith('fg-')) twClass = `text-${name}`;
    else if (name.startsWith('border-')) twClass = `border-${name}`;
    else if (name.startsWith('focus-')) twClass = `ring-${name}`;
    else if (name.startsWith('shadow-')) twClass = `shadow-(--color-${name})`;
    else if (name.startsWith('alpha-')) twClass = `bg-${name}`;
    else if (name.includes('-icon') || name.includes('-fg')) twClass = `text-${name}`;
    else if (name.includes('-bg') || name.includes('-handle')) twClass = `bg-${name}`;
    else if (name.includes('-border')) twClass = `border-${name}`;
    else twClass = `text-${name}`;

    lines.push(`| \`--color-${name}\` | \`${twClass}\` | ${toKebab(category)} |\n`);
  }

  // Typography composites
  lines.push('\n## Typography Composite Tokens\n\n');
  lines.push('Each `text-*` utility applies font-size, line-height, letter-spacing, and font-weight.\n');
  lines.push('Pair with a `font-*` utility for the font family.\n\n');
  lines.push('| Tailwind Class | Font-Size | Line-Height | Letter-Spacing | Font-Weight | Font Class |\n');
  lines.push('|---|---|---|---|---|---|\n');

  const typo = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticType, ...COLLECTION_NAMES.semanticTypeLegacy],
    'Semantic typography',
  );
  const typoMode = getModeData(typo.collection, ['Value', 'Mode 1', 'Style']);

  for (const [category, variants] of Object.entries(typoMode)) {
    if (category.startsWith('$')) continue;
    for (const [variant, sizes] of Object.entries(variants)) {
      if (variant.startsWith('$')) continue;

      // Direct preset (no size level)
      if (sizes.Font || sizes.Style || sizes.Size) {
        const preset = sizes;
        const presetName = `${toKebab(category)}-${toKebab(variant)}`;
        emitPresetReference(presetName, preset, collections, lines);
        continue;
      }

      for (const [size, preset] of Object.entries(sizes)) {
        if (size.startsWith('$')) continue;
        if (!preset.Font && !preset.Style && !preset.Size) continue;
        const presetName = `${toKebab(category)}-${toKebab(variant)}-${toKebab(size)}`;
        emitPresetReference(presetName, preset, collections, lines);
      }
    }
  }

  // Width tokens
  lines.push('\n## Width Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Value |\n');
  lines.push('|---|---|---|\n');
  const widths = requireCollection(
    collections,
    [...COLLECTION_NAMES.semanticWidth, ...COLLECTION_NAMES.semanticWidthLegacy],
    'Semantic width',
  );
  const widthsMode = getModeData(widths.collection, ['Mode 1', 'Value', 'Style']);
  for (const [key, node] of Object.entries(widthsMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const pxValue = typeof resolvedValue === 'number' ? resolvedValue : parseInt(resolvedValue, 10);
    lines.push(`| \`--width-${key.replace(/^width-/, '')}\` | \`w-${key.replace(/^width-/, '')}\` | \`${pxValue}px\` |\n`);
  }

  // Breakpoints
  lines.push('\n## Breakpoints\n\n');
  lines.push('| CSS Property | Responsive Prefix | Value |\n');
  lines.push('|---|---|---|\n');
  const breakpointMap = {
    'sm': 480, 'md': 640, 'lg': 768,
    'xl': 1024, '2xl': 1280, '3xl': 1440,
  };
  for (const [name, value] of Object.entries(breakpointMap)) {
    lines.push(`| \`--breakpoint-${name}\` | \`${name}:\` | \`${value}px\` |\n`);
  }

  return lines.join('');
}

function emitPresetReference(presetName, preset, collections, lines) {
  const sizeVal = preset.Size
    ? resolveReference(preset.Size.$value, preset.Size.$collectionName || '_Alias', collections)
    : '?';
  const lineVal = preset.Line
    ? resolveReference(preset.Line.$value, preset.Line.$collectionName || '_Alias', collections)
    : '?';
  const letterVal = preset.Letter
    ? resolveReference(preset.Letter.$value, preset.Letter.$collectionName || '_Alias', collections)
    : 0;
  const styleVal = preset.Style
    ? resolveReference(preset.Style.$value, preset.Style.$collectionName || '_Alias', collections)
    : 'Regular';

  const fontRef = preset.Font
    ? resolveReference(preset.Font.$value, preset.Font.$collectionName || '_Alias', collections)
    : '?';

  // Determine font slot
  let fontSlot = 'font-primary';
  if (typeof fontRef === 'string') {
    const fontLower = fontRef.toLowerCase();
    if (fontLower.includes('electric') || fontLower.includes('deco')) fontSlot = 'font-display-deco';
    else if (fontLower.includes('chillax') || fontLower.includes('plain')) fontSlot = 'font-display-plain';
    else if (fontLower.includes('oxanium') || fontLower.includes('label')) fontSlot = 'font-label';
  }
  // Also check the Font reference path for alias names
  if (preset.Font && typeof preset.Font.$value === 'string') {
    const ref = preset.Font.$value;
    if (ref.includes('Secondary - Deco')) fontSlot = 'font-display-deco';
    else if (ref.includes('Secondary - Plain') || ref.includes('Secondary  - Plain')) fontSlot = 'font-display-plain';
    else if (ref.includes('Tertiary')) fontSlot = 'font-label';
    else if (ref.includes('Primary')) fontSlot = 'font-primary';
  }

  const sizeRem = typeof sizeVal === 'number' ? pxToRem(sizeVal) : sizeVal;
  const lineRem = typeof lineVal === 'number' ? pxToRem(lineVal) : lineVal;
  const letterEm = typeof letterVal === 'number' ? letterSpacingToEm(letterVal) : letterVal;
  const weight = FONT_WEIGHT_MAP[styleVal] || 400;

  lines.push(`| \`text-${presetName}\` | ${sizeRem} | ${lineRem} | ${letterEm} | ${weight} | \`${fontSlot}\` |\n`);
}

// ─── CLI, Diff, Validation & Stats ───────────────────────────────────────────

function parseCliArgs(argv) {
  const options = {
    input: null,
    validate: false,
    stats: false,
    diff: false,
    outputDir: DEFAULT_OUTPUT_DIR,
  };

  const positional = [];

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    if (arg === '--input') {
      const value = argv[++i];
      if (!value) throw new Error('--input requires a value');
      options.input = value;
      continue;
    }

    if (arg === '--output-dir') {
      const value = argv[++i];
      if (!value) throw new Error('--output-dir requires a value');
      options.outputDir = value;
      continue;
    }

    if (arg === '--validate') {
      options.validate = true;
      continue;
    }

    if (arg === '--stats') {
      options.stats = true;
      continue;
    }

    if (arg === '--diff') {
      options.diff = true;
      continue;
    }

    if (arg.startsWith('--')) {
      throw new Error(`Unknown flag: ${arg}`);
    }

    positional.push(arg);
  }

  if (!options.input && positional.length > 0) {
    options.input = positional[0];
  }

  return options;
}

async function pathStatOrNull(path) {
  try {
    return await stat(path);
  } catch {
    return null;
  }
}

async function findLatestDesignSystemExport() {
  const designVarDir = join(ROOT, 'Design System/var');
  let entries;
  try {
    entries = await readdir(designVarDir, { withFileTypes: true });
  } catch {
    return null;
  }

  const candidates = [];
  for (const entry of entries) {
    if (!entry.isFile() || !entry.name.toLowerCase().endsWith('.json')) continue;
    const fullPath = join(designVarDir, entry.name);
    const st = await pathStatOrNull(fullPath);
    if (!st) continue;
    candidates.push({ path: fullPath, mtimeMs: st.mtimeMs, mtime: st.mtime });
  }

  if (candidates.length === 0) return null;

  candidates.sort((a, b) => b.mtimeMs - a.mtimeMs);
  return candidates[0];
}

async function resolveInputFile(explicitInput) {
  if (explicitInput) {
    const st = await stat(explicitInput);
    return { path: explicitInput, mtime: st.mtime };
  }

  const latest = await findLatestDesignSystemExport();
  if (latest) {
    return { path: latest.path, mtime: latest.mtime };
  }

  const st = await stat(DEFAULT_JSON);
  return { path: DEFAULT_JSON, mtime: st.mtime };
}

function parseCustomProperties(cssText) {
  const entries = [];
  const regex = /(--[a-zA-Z0-9_-]+)\s*:\s*([^;]+);/g;
  let match;
  while ((match = regex.exec(cssText)) !== null) {
    entries.push({
      name: match[1],
      value: match[2].trim(),
      index: match.index,
    });
  }
  return entries;
}

function blockContent(cssText, selectorRegex) {
  const match = cssText.match(selectorRegex);
  return match ? match[1] : '';
}

function parseSelectorBlocks(cssText) {
  const blocks = [];
  const regex = /(@theme inline|@theme|:root|\[data-theme="dark"\])\s*\{([\s\S]*?)\}/g;
  let match;
  while ((match = regex.exec(cssText)) !== null) {
    blocks.push({ selector: match[1], content: match[2] });
  }
  if (blocks.length === 0) {
    blocks.push({ selector: '<file>', content: cssText });
  }
  return blocks;
}

function normaliseSimpleValue(value) {
  return value
    .replace(/\s+/g, ' ')
    .replace(/\b0px\b/g, '0')
    .trim();
}

function collectFileEntriesMap(generatedFiles) {
  const byFile = new Map();
  for (const [fileName, cssText] of Object.entries(generatedFiles)) {
    byFile.set(fileName, parseCustomProperties(cssText));
  }
  return byFile;
}

function collectUniquePropertyMap(generatedFiles) {
  const map = new Map();
  for (const fileName of OUTPUT_FILES) {
    const cssText = generatedFiles[fileName] || '';
    const entries = parseCustomProperties(cssText);
    for (const entry of entries) {
      if (!map.has(entry.name)) {
        map.set(entry.name, entry.value);
      }
    }
  }
  return map;
}

async function capturePreviousOutputs(outputDir) {
  const previous = {};
  for (const fileName of OUTPUT_FILES) {
    const fullPath = join(outputDir, fileName);
    try {
      previous[fileName] = await readFile(fullPath, 'utf-8');
    } catch {
      // Ignore missing files.
    }
  }
  return previous;
}

function buildDiffSummary(previousFiles, nextFiles) {
  const previousMap = collectUniquePropertyMap(previousFiles);
  const nextMap = collectUniquePropertyMap(nextFiles);

  const added = [];
  const removed = [];
  const changed = [];

  for (const [name, value] of nextMap) {
    if (!previousMap.has(name)) {
      added.push(name);
      continue;
    }
    const beforeValue = previousMap.get(name);
    if (normaliseSimpleValue(beforeValue) !== normaliseSimpleValue(value)) {
      changed.push(name);
    }
  }

  for (const name of previousMap.keys()) {
    if (!nextMap.has(name)) {
      removed.push(name);
    }
  }

  return { added, removed, changed };
}

function extractVarReferences(value) {
  const refs = [];
  const varRegex = /var\(\s*(--[a-zA-Z0-9_-]+)\s*(?:,[^)]+)?\)/g;
  let match;
  while ((match = varRegex.exec(value)) !== null) {
    refs.push(match[1]);
  }
  return refs;
}

function parseOklchValues(value) {
  const matches = [];
  const regex = /oklch\(([^)]+)\)/gi;
  let match;
  while ((match = regex.exec(value)) !== null) {
    matches.push(match[1].trim());
  }
  return matches;
}

function isValidOklch(inside) {
  const [core] = inside.split('/');
  const parts = core.trim().split(/\s+/).filter(Boolean);
  if (parts.length < 3) return false;

  const lightnessRaw = parts[0];
  if (!lightnessRaw.endsWith('%')) return false;

  const lightness = Number.parseFloat(lightnessRaw.slice(0, -1));
  const chroma = Number.parseFloat(parts[1]);
  const hue = Number.parseFloat(parts[2]);

  if (!Number.isFinite(lightness) || lightness < 0 || lightness > 100) return false;
  if (!Number.isFinite(chroma) || chroma < 0) return false;
  if (!Number.isFinite(hue) || hue < 0 || hue > 360) return false;
  return true;
}

function hasConsecutiveStutter(name) {
  const parts = name.replace(/^--/, '').split('-').filter(Boolean);
  for (let i = 1; i < parts.length; i++) {
    if (parts[i] === parts[i - 1]) {
      return true;
    }
  }
  return false;
}

function validateGeneratedFiles(generatedFiles) {
  const checks = [];
  const byFile = collectFileEntriesMap(generatedFiles);
  const declaredNames = new Set();
  for (const entries of byFile.values()) {
    for (const entry of entries) declaredNames.add(entry.name);
  }

  // 1. No duplicate property names within any single file
  {
    const duplicates = [];
    for (const [fileName, cssText] of Object.entries(generatedFiles)) {
      const blocks = parseSelectorBlocks(cssText);
      for (const block of blocks) {
        const seen = new Set();
        const entries = parseCustomProperties(block.content);
        for (const entry of entries) {
          if (seen.has(entry.name)) {
            duplicates.push(`${fileName} ${block.selector}: ${entry.name}`);
          } else {
            seen.add(entry.name);
          }
        }
      }
    }
    checks.push({
      name: 'No duplicate property names per file',
      pass: duplicates.length === 0,
      details: duplicates,
    });
  }

  // 2. All var() references resolve
  {
    const unresolved = [];
    for (const [fileName, entries] of byFile) {
      for (const entry of entries) {
        for (const ref of extractVarReferences(entry.value)) {
          if (!declaredNames.has(ref)) {
            unresolved.push(`${fileName}: ${entry.name} -> ${ref}`);
          }
        }
      }
    }
    checks.push({
      name: 'All var() references resolve',
      pass: unresolved.length === 0,
      details: unresolved,
    });
  }

  // 3. Dark mode coverage parity
  {
    const semanticInline = generatedFiles['semantic-inline.css'] || '';
    const rootEntries = parseCustomProperties(blockContent(semanticInline, /:root\s*\{([\s\S]*?)\}\s*/m));
    const darkEntries = parseCustomProperties(blockContent(semanticInline, /\[data-theme="dark"\]\s*\{([\s\S]*?)\}\s*/m));

    const rootSet = new Set(rootEntries.map(entry => entry.name));
    const darkSet = new Set(darkEntries.map(entry => entry.name));
    const missingInDark = [...rootSet].filter(name => !darkSet.has(name));

    checks.push({
      name: 'Dark mode coverage for semantic-inline',
      pass: missingInDark.length === 0 && rootSet.size > 0,
      details: missingInDark.map(name => `Missing dark override: ${name}`),
    });
  }

  // 4. OKLCH validity
  {
    const invalid = [];
    for (const [fileName, entries] of byFile) {
      for (const entry of entries) {
        const oklchValues = parseOklchValues(entry.value);
        for (const oklchValue of oklchValues) {
          if (!isValidOklch(oklchValue)) {
            invalid.push(`${fileName}: ${entry.name} -> oklch(${oklchValue})`);
          }
        }
      }
    }
    checks.push({
      name: 'OKLCH values are valid',
      pass: invalid.length === 0,
      details: invalid,
    });
  }

  // 5. No stutter names
  {
    const stutters = [];
    for (const [fileName, entries] of byFile) {
      for (const entry of entries) {
        if (hasConsecutiveStutter(entry.name)) {
          stutters.push(`${fileName}: ${entry.name}`);
        }
      }
    }
    checks.push({
      name: 'No stutter in variable names',
      pass: stutters.length === 0,
      details: stutters,
    });
  }

  // 6. Grey not gray
  {
    const grayNames = [];
    for (const [fileName, entries] of byFile) {
      for (const entry of entries) {
        if (entry.name.includes('gray')) {
          grayNames.push(`${fileName}: ${entry.name}`);
        }
      }
    }
    checks.push({
      name: 'Variable names use "grey", not "gray"',
      pass: grayNames.length === 0,
      details: grayNames,
    });
  }

  // 7. Token count sanity
  {
    const fileCounts = [];
    let pass = true;
    for (const fileName of OUTPUT_FILES) {
      const count = (byFile.get(fileName) || []).length;
      fileCounts.push(`${fileName}: ${count}`);
      if (count === 0) pass = false;
    }
    checks.push({
      name: 'Token count sanity (no empty files)',
      pass,
      details: fileCounts,
    });
  }

  const passed = checks.every(check => check.pass);
  return { passed, checks };
}

function printValidationReport(report) {
  console.log('\n─── Validation ───');
  for (const check of report.checks) {
    console.log(`${check.pass ? '[PASS]' : '[FAIL]'} ${check.name}`);
    if (!check.pass && check.details.length > 0) {
      for (const detail of check.details.slice(0, 20)) {
        console.log(`  - ${detail}`);
      }
      if (check.details.length > 20) {
        console.log(`  - ...and ${check.details.length - 20} more`);
      }
    }
  }
}

function computeTokenStats(generatedFiles) {
  const primitives = parseCustomProperties(generatedFiles['primitives.css'] || '');
  const aliases = parseCustomProperties(generatedFiles['aliases.css'] || '');
  const semantic = parseCustomProperties(generatedFiles['semantic.css'] || '');
  const semanticInline = parseCustomProperties(generatedFiles['semantic-inline.css'] || '');

  const primitivesBreakdown = {
    colours: primitives.filter(entry => entry.name.startsWith('--primitive-color-')).length,
    dimensions: primitives.filter(entry => entry.name.startsWith('--primitive-dimension-')).length,
    fonts: primitives.filter(entry => entry.name.startsWith('--primitive-font-')).length,
    typeScale: primitives.filter(entry => entry.name.startsWith('--primitive-type-scale-')).length,
    letterSpacing: primitives.filter(entry => entry.name.startsWith('--primitive-letter-spacing-')).length,
    paragraph: primitives.filter(entry => entry.name.startsWith('--primitive-paragraph-spacing-')).length,
  };

  const aliasesBreakdown = {
    fontFamilies: aliases.filter(entry => /^--alias-font-(primary|display-plain|display-deco|label)$/.test(entry.name)).length,
    fontWeights: aliases.filter(entry => entry.name.startsWith('--alias-font-style-')).length,
    fontSizes: aliases.filter(entry => entry.name.startsWith('--alias-font-size-')).length,
    lineHeights: aliases.filter(entry => entry.name.startsWith('--alias-line-height-')).length,
    letterSpacing: aliases.filter(entry => entry.name.startsWith('--alias-letter-spacing-')).length,
  };
  aliasesBreakdown.colours = aliases.length
    - aliasesBreakdown.fontFamilies
    - aliasesBreakdown.fontWeights
    - aliasesBreakdown.fontSizes
    - aliasesBreakdown.lineHeights
    - aliasesBreakdown.letterSpacing;

  const semanticBreakdown = {
    fonts: semantic.filter(entry => entry.name.startsWith('--font-')).length,
    spacing: semantic.filter(entry => entry.name.startsWith('--spacing-')).length,
    radius: semantic.filter(entry => entry.name.startsWith('--radius-')).length,
    breakpoints: semantic.filter(entry => entry.name.startsWith('--breakpoint-')).length,
    typographyComposites: semantic.filter(entry => entry.name.startsWith('--text-')).length,
    widths: semantic.filter(entry => entry.name.startsWith('--width-')).length,
    containers: semantic.filter(entry => entry.name.startsWith('--container-')).length,
  };

  const semanticCore = semantic.length - semanticBreakdown.widths - semanticBreakdown.containers;
  const semanticInlineUnique = parseCustomProperties(blockContent(generatedFiles['semantic-inline.css'] || '', /:root\s*\{([\s\S]*?)\}\s*/m)).length;
  const semanticInlineDeclarations = semanticInline.length;

  const allEntries = [...primitives, ...aliases, ...semantic, ...semanticInline];
  const uniqueTokens = new Set(allEntries.map(entry => entry.name)).size;
  const varRefs = allEntries.reduce((sum, entry) => sum + extractVarReferences(entry.value).length, 0);
  const hasOnlyOklch = primitivesBreakdown.colours > 0
    && primitives
      .filter(entry => entry.name.startsWith('--primitive-color-'))
      .every(entry => parseOklchValues(entry.value).length > 0);

  return {
    primitives,
    aliases,
    semantic,
    semanticInline,
    primitivesBreakdown,
    aliasesBreakdown,
    semanticBreakdown,
    semanticCore,
    semanticInlineUnique,
    semanticInlineDeclarations,
    uniqueTokens,
    totalDeclarations: allEntries.length,
    varRefs,
    colorFormat: hasOnlyOklch ? 'oklch' : 'mixed',
  };
}

function printTokenStats(stats) {
  console.log('\nToken Statistics:');
  console.log(
    `Primitives: ${stats.primitives.length} (${stats.primitivesBreakdown.colours} colours, ${stats.primitivesBreakdown.dimensions} dimensions, ${stats.primitivesBreakdown.fonts} fonts, ${stats.primitivesBreakdown.typeScale} type scale, ${stats.primitivesBreakdown.letterSpacing} letter spacing, ${stats.primitivesBreakdown.paragraph} paragraph)`,
  );
  console.log(
    `Aliases: ${stats.aliases.length} (${stats.aliasesBreakdown.fontFamilies} font families, ${stats.aliasesBreakdown.fontWeights} font weights, ${stats.aliasesBreakdown.fontSizes} font sizes, ${stats.aliasesBreakdown.lineHeights} line heights, ${stats.aliasesBreakdown.letterSpacing} letter spacing, ${stats.aliasesBreakdown.colours} colours)`,
  );
  console.log(
    `Semantic: ${stats.semanticCore} (${stats.semanticBreakdown.fonts} fonts, ${stats.semanticBreakdown.spacing} spacing, ${stats.semanticBreakdown.radius} radius, ${stats.semanticBreakdown.breakpoints} breakpoints, ${stats.semanticBreakdown.typographyComposites} typography composites)`,
  );
  console.log(
    `Semantic Inline: ${stats.semanticInlineUnique} (×3 = ${stats.semanticInlineDeclarations} declarations across light/dark/registration)`,
  );
  console.log(`Widths: ${stats.semanticBreakdown.widths}`);
  console.log(`Containers: ${stats.semanticBreakdown.containers}`);
  console.log(`\nTotal unique tokens: ${stats.uniqueTokens}`);
  console.log(`Total CSS declarations: ${stats.totalDeclarations} (including dark mode duplicates)`);
  console.log(`\nColor format: ${stats.colorFormat}`);
  console.log('Spacing unit: rem (except width/breakpoint: px)');
  console.log(`Reference chains: ${stats.varRefs} var() references`);
}

// ─── Main ────────────────────────────────────────────────────────────────────

async function main() {
  const options = parseCliArgs(process.argv.slice(2));
  const input = await resolveInputFile(options.input);
  const jsonPath = input.path;
  const outputDir = options.outputDir;
  const previousOutputs = options.diff ? await capturePreviousOutputs(outputDir) : {};

  console.log('╔══════════════════════════════════════════════╗');
  console.log('║  ONEMO Design Token Pipeline — build-tokens  ║');
  console.log('╚══════════════════════════════════════════════╝');
  console.log(`\nSource: ${jsonPath}`);
  console.log(`Selected input mtime: ${input.mtime.toISOString()}`);
  console.log(`Output: ${outputDir}/\n`);

  // Read and parse JSON
  const raw = await readFile(jsonPath, 'utf-8');
  const json = JSON.parse(raw);
  const collections = parseCollections(json);

  console.log(`Collections found: ${[...collections.keys()].join(', ')}\n`);

  // Ensure output directory exists
  await mkdir(outputDir, { recursive: true });

  // Generate CSS files
  const primitives = generatePrimitivesCSS(collections);
  const aliases = generateAliasesCSS(collections);
  const semantic = generateSemanticCSS(collections);
  const semanticInline = generateSemanticInlineCSS(collections);
  const generatedFiles = {
    'primitives.css': primitives.css,
    'aliases.css': aliases.css,
    'semantic.css': semantic.css,
    'semantic-inline.css': semanticInline.css,
  };

  // Write CSS files
  await writeFile(join(outputDir, 'primitives.css'), primitives.css);
  await writeFile(join(outputDir, 'aliases.css'), aliases.css);
  await writeFile(join(outputDir, 'semantic.css'), semantic.css);
  await writeFile(join(outputDir, 'semantic-inline.css'), semanticInline.css);

  // Generate and write token reference
  const tokenRef = generateTokenReference(collections);
  const ssotDir = join(ROOT, '..', 'onemo-ssot-global', '11-design-system');
  let ssotWritten = false;
  try {
    if (outputDir === DEFAULT_OUTPUT_DIR) {
      await writeFile(join(ssotDir, '11.9-token-reference.md'), tokenRef);
      ssotWritten = true;
    } else {
      throw new Error('Skip SSOT write for custom output directory');
    }
  } catch {
    // SSOT repo not available — write locally as fallback
    await writeFile(join(outputDir, 'token-reference.md'), tokenRef);
  }

  // Summary
  console.log('─── Generated Files ───');
  console.log(`  primitives.css:       ${primitives.count} tokens`);
  console.log(`  aliases.css:          ${aliases.count} tokens`);
  console.log(`  semantic.css:         ${semantic.count} tokens`);
  console.log(`  semantic-inline.css:  ${semanticInline.count} tokens (×3 sections)`);
  console.log(`  11.9-token-reference.md: ${ssotWritten ? 'written to SSOT' : 'written locally (SSOT repo not found)'}`);
  console.log(`\nTotal: ${primitives.count + aliases.count + semantic.count + semanticInline.count} CSS custom properties\n`);

  if (options.diff) {
    const hasPrevious = OUTPUT_FILES.some(fileName => previousOutputs[fileName]);
    console.log('─── Diff Summary ───');
    if (hasPrevious) {
      const diffSummary = buildDiffSummary(previousOutputs, generatedFiles);
      console.log(`${diffSummary.added.length} tokens added, ${diffSummary.removed.length} tokens removed, ${diffSummary.changed.length} tokens changed`);
    } else {
      console.log('No previous token output found in destination directory; diff skipped.');
    }
    console.log('');
  }

  if (options.stats) {
    const stats = computeTokenStats(generatedFiles);
    printTokenStats(stats);
    console.log('');
  }

  let validationReport = null;
  if (options.validate) {
    validationReport = validateGeneratedFiles(generatedFiles);
    printValidationReport(validationReport);
    console.log('');
  }

  console.log('✅ Done. Run `npm run dev` to verify.\n');

  if (validationReport && !validationReport.passed) {
    process.exit(1);
  }
}

main().catch(err => {
  console.error('❌ Build failed:', err.message);
  process.exit(1);
});
