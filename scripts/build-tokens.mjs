#!/usr/bin/env node
/**
 * build-tokens.mjs — ONEMO Design Token Pipeline
 *
 * Reads the Figma Variables JSON export and generates 4 CSS files:
 *   - src/app/tokens/primitives.css    (Layer 1 — :root)
 *   - src/app/tokens/aliases.css       (Layer 2 — :root)
 *   - src/app/tokens/semantic.css      (Layer 3 — @theme)
 *   - src/app/tokens/semantic-inline.css (Layer 3 — :root + dark + @theme inline)
 *
 * Zero dependencies. Node.js 18+ (uses fs/promises, path, URL).
 *
 * Usage:
 *   node scripts/build-tokens.mjs [path-to-json]
 *
 * Default JSON path:
 *   Design System/var/Figma Variables Export 16-02-26 CLEANED.json
 *
 * Documentation: onemo-ssot-global/11-design-system/11.8-css-pipeline.md
 * Naming rules: onemo-ssot-global/11-design-system/11.5-naming-convention.md
 */

import { readFile, writeFile, mkdir } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, '..');
const DEFAULT_JSON = join(ROOT, 'Design System/var/Figma Variables Export 16-02-26 CLEANED.json');
const OUTPUT_DIR = join(ROOT, 'src/app/tokens');

const HEADER = `/* Auto-generated by build-tokens.mjs from Figma Variables Export
   Source: Design System/var/Figma Variables Export 16-02-26 CLEANED.json
   DO NOT EDIT — regenerate with: node scripts/build-tokens.mjs */\n\n`;

// ─── Naming Transform Helpers ────────────────────────────────────────────────

/**
 * Font weight mapping: Figma style name → CSS numeric weight
 */
const FONT_WEIGHT_MAP = {
  'ExtraLight': 200,
  'Extra Light': 200,
  'Light': 300,
  'Regular': 400,
  'Medium': 500,
  'SemiBold': 600,
  'Semi Bold': 600,
  'Bold': 700,
  'ExtraBold': 800,
  'Extra Bold': 800,
  'Black': 900,
  'Regular Italic': 400,
  'Medium Italic': 500,
  'Semi Bold Italic': 600,
  'Bold Italic': 700,
};

/**
 * Font family alias mapping: Figma key → CSS semantic name
 */
const FONT_FAMILY_ALIAS_MAP = {
  'Primary': 'primary',
  'Secondary - Plain': 'display-plain',
  'Secondary - Deco': 'display-deco',
  'Tertiary': 'label',
};

/**
 * Spacing Figma name → semantic name mapping
 * Maps Figma dimension references like "Dimensions.0 (0px)" → resolved px value
 */
const SPACING_NAMES = [
  'spacing-none', 'spacing-xxs', 'spacing-xs', 'spacing-sm', 'spacing-md',
  'spacing-lg', 'spacing-xl', 'spacing-2xl', 'spacing-3xl', 'spacing-4xl',
  'spacing-5xl', 'spacing-6xl', 'spacing-7xl', 'spacing-8xl', 'spacing-9xl',
  'spacing-10xl', 'spacing-11xl',
];

/**
 * Transform a key name to CSS-safe kebab-case
 * Steps from 11.5 Section 1.1:
 *  - Lowercase
 *  - Remove parenthetical annotations
 *  - Replace Unicode One Dot Leader (U+2024) with hyphen
 *  - Replace spaces with hyphens
 *  - Collapse multiple hyphens
 *  - Replace underscores with hyphens
 */
function toKebab(str) {
  return str
    .toLowerCase()
    // Remove parenthetical annotations: "(900)", "(0px)", "(1,024px)", etc.
    .replace(/\s*\([^)]*\)\s*/g, '')
    // Replace Unicode One Dot Leader (U+2024) with hyphen
    .replace(/\u2024/g, '-')
    // Replace spaces with hyphens
    .replace(/\s+/g, '-')
    // Replace underscores with hyphens
    .replace(/_/g, '-')
    // Collapse multiple hyphens
    .replace(/-{2,}/g, '-')
    // Remove leading/trailing hyphens
    .replace(/^-|-$/g, '');
}

/**
 * Like toKebab but preserves mode annotations in parentheses:
 * "Gray (light mode)" → "gray-light"
 * "Gray (dark mode)" → "gray-dark"
 * "Gray (dark mode alpha)" → "gray-dark-alpha"
 */
function toKebabPreserveMode(str) {
  return str
    .toLowerCase()
    // Transform mode annotations into part of the name
    .replace(/\s*\(([^)]*)\)\s*/g, (match, content) => {
      if (content.includes('light mode') || content.includes('dark mode')) {
        return '-' + content.replace(/\s+mode\s*/g, '').replace(/\s+/g, '-');
      }
      return '';
    })
    .replace(/\u2024/g, '-')
    .replace(/\s+/g, '-')
    .replace(/_/g, '-')
    .replace(/-{2,}/g, '-')
    .replace(/^-|-$/g, '');
}

/**
 * Convert Figma letter-spacing percentage to em
 * Chrome <145 doesn't support % for letter-spacing
 * Formula: em = figmaPercentValue / 100
 */
function letterSpacingToEm(percentValue) {
  if (percentValue === 0) return '0em';
  const em = percentValue / 100;
  // Avoid floating point noise: round to 4 decimal places
  const rounded = Math.round(em * 10000) / 10000;
  return `${rounded}em`;
}

/**
 * Convert px to rem (base 16px)
 */
function pxToRem(px) {
  if (px === 0) return '0px';
  const rem = px / 16;
  // Clean up floating point
  const rounded = Math.round(rem * 10000) / 10000;
  return `${rounded}rem`;
}

// ─── JSON Parsing & Reference Resolution ─────────────────────────────────────

/**
 * Parse the JSON array into a Map of collection name → collection data
 */
function parseCollections(json) {
  const collections = new Map();
  for (const entry of json) {
    const collectionName = Object.keys(entry)[0];
    collections.set(collectionName, entry[collectionName]);
  }
  return collections;
}

/**
 * Walk a dot-separated path through a nested object
 * Handles Figma's path format: "Colors.Neutral.Gray (light mode).900"
 * Keys can contain dots — but in practice the Figma plugin uses dots as path separators
 */
function walkPath(obj, pathStr) {
  // Split by dots, but we need to handle keys that might contain dots
  // In the Figma export, path segments match JSON keys exactly
  const segments = pathStr.split('.');
  let current = obj;

  for (const seg of segments) {
    if (!current || typeof current !== 'object') return undefined;
    if (seg in current) {
      current = current[seg];
    } else {
      // Try progressively joining segments for keys with dots
      return undefined;
    }
  }
  return current;
}

/**
 * Resolve a reference value to its final literal value
 * References look like: "{Colors.Neutral.Gray (light mode).900}"
 * The $collectionName tells us which collection to look in
 */
function resolveReference(value, collectionName, collections, depth = 0) {
  if (depth > 5) {
    console.warn(`Max reference depth exceeded for: ${value}`);
    return value;
  }

  // Literal value (not a reference)
  if (typeof value !== 'string' || !value.startsWith('{') || !value.endsWith('}')) {
    return value;
  }

  const path = value.slice(1, -1); // Remove { and }
  const targetCollection = collections.get(collectionName);

  if (!targetCollection) {
    console.warn(`Collection not found: ${collectionName} for ref ${value}`);
    return value;
  }

  // Walk through the collection's modes to find the value
  // Most collections have a single mode, but Color modes has Light/Dark
  const modes = targetCollection.modes;
  for (const modeName of Object.keys(modes)) {
    const result = walkPath(modes[modeName], path);
    if (result && result.$value !== undefined) {
      // If this is also a reference, resolve recursively
      const nextCollection = result.$collectionName || collectionName;
      return resolveReference(result.$value, nextCollection, collections, depth + 1);
    }
  }

  console.warn(`Could not resolve reference: ${value} in collection ${collectionName}`);
  return value;
}

/**
 * Flatten a nested object tree into an array of { path: [...], node: {...} } entries
 * Stops at leaf nodes (objects with $value)
 */
function flattenTree(obj, pathSoFar = []) {
  const results = [];

  for (const [key, val] of Object.entries(obj)) {
    if (key.startsWith('$')) continue; // Skip metadata keys

    if (val && typeof val === 'object' && '$value' in val) {
      // Leaf node
      results.push({ path: [...pathSoFar, key], node: val });
    } else if (val && typeof val === 'object') {
      // Branch — recurse
      results.push(...flattenTree(val, [...pathSoFar, key]));
    }
  }

  return results;
}

// ─── CSS Generation: Primitives ──────────────────────────────────────────────

function generatePrimitivesCSS(collections) {
  const primitives = collections.get('_Primitives');
  const modeData = primitives.modes.Core;
  const entries = flattenTree(modeData);
  const lines = [HEADER, ':root {\n'];
  let count = 0;
  let currentCategory = '';

  for (const { path, node } of entries) {
    const category = path[0];
    if (category !== currentCategory) {
      if (currentCategory) lines.push('\n');
      lines.push(`  /* ═══ ${path.slice(0, Math.min(2, path.length)).join(' > ')} ═══ */\n`);
      currentCategory = category;
    }

    const propName = buildPrimitiveName(path, node);
    const cssValue = formatPrimitiveValue(path, node);

    lines.push(`  ${propName}: ${cssValue};\n`);
    count++;
  }

  lines.push('}\n');
  return { css: lines.join(''), count };
}

function buildPrimitiveName(path, node) {
  // Special handling for different primitive categories
  const category = path[0];

  if (category === 'Colors') {
    // Colors/Base/white → --primitive-color-base-white
    // Colors/Neutral/Gray (light mode)/500 → --primitive-color-gray-light-500
    // Colors/Neutral/Gray (dark mode)/500 → --primitive-color-gray-dark-500
    // Colors/Neutral/Gray (dark mode alpha)/500 → --primitive-color-gray-dark-alpha-500
    // Colors/ONEMO - UI Palette/Dusty/Blue Green/500 → --primitive-color-blue-green-500
    const parts = path.slice(1); // Remove "Colors"

    // Skip "ONEMO - UI Palette", "Dusty", and "Neutral" intermediate groups
    const filtered = parts.filter(p =>
      p !== 'ONEMO - UI Palette' && p !== 'Dusty' && p !== 'Neutral'
    );

    // Use toKebabPreserveMode for gray names to preserve light/dark distinction
    return `--primitive-color-${filtered.map(p => toKebabPreserveMode(p)).join('-')}`;
  }

  if (category === 'Dimensions') {
    // Dimensions/4 (16px) → --primitive-dimension-4
    const dimName = toKebab(path[1]);
    return `--primitive-dimension-${dimName}`;
  }

  if (category === 'Typography') {
    const subCategory = path[1];

    if (subCategory === 'Type Scale') {
      // Typography/Type Scale/72 → --primitive-type-scale-72
      return `--primitive-type-scale-${path[2]}`;
    }

    if (subCategory === 'Letter Spacing') {
      // Typography/Letter Spacing/+10 → --primitive-letter-spacing-pos-10
      // Typography/Letter Spacing/-10 → --primitive-letter-spacing-neg-10
      // Typography/Letter Spacing/zero → --primitive-letter-spacing-0
      const rawName = path[2];
      if (rawName === 'zero') return '--primitive-letter-spacing-0';
      if (rawName.startsWith('+')) return `--primitive-letter-spacing-pos-${rawName.slice(1)}`;
      if (rawName.startsWith('-')) return `--primitive-letter-spacing-neg-${rawName.slice(1)}`;
      return `--primitive-letter-spacing-${rawName}`;
    }

    if (subCategory === 'Font Family') {
      // Typography/Font Family/Basic/Satoshi → --primitive-font-satoshi
      // Typography/Font Family/Decorative/Electric Blue → --primitive-font-electric-blue
      const fontName = path[path.length - 1];
      return `--primitive-font-${toKebab(fontName)}`;
    }

    if (subCategory === 'Paragraph Spacing') {
      return `--primitive-paragraph-spacing-${toKebab(path[2])}`;
    }
  }

  // Fallback
  return `--primitive-${path.map(p => toKebab(p)).join('-')}`;
}

function formatPrimitiveValue(path, node) {
  const category = path[0];
  const value = node.$value;

  if (category === 'Colors') {
    // Color values — output as-is (hex or rgba)
    return value;
  }

  if (category === 'Dimensions') {
    // Dimensions in px → convert to rem (except 0)
    if (typeof value === 'number') {
      return value === 0 ? '0px' : pxToRem(value);
    }
    return `${value}`;
  }

  if (category === 'Typography') {
    const subCategory = path[1];

    if (subCategory === 'Type Scale') {
      // Type scale values are px → convert to rem
      return typeof value === 'number' ? pxToRem(value) : `${value}`;
    }

    if (subCategory === 'Letter Spacing') {
      // Letter spacing: Figma stores as percentage number → convert to em
      return typeof value === 'number' ? letterSpacingToEm(value) : `${value}`;
    }

    if (subCategory === 'Font Family') {
      // Font family: wrap in quotes, add generic fallback
      const fontName = String(value);
      return `"${fontName}", sans-serif`;
    }

    if (subCategory === 'Paragraph Spacing') {
      // Paragraph spacing: output as px
      return typeof value === 'number' ? `${value}px` : `${value}`;
    }
  }

  return `${value}`;
}

// ─── CSS Generation: Aliases ─────────────────────────────────────────────────

function generateAliasesCSS(collections) {
  const alias = collections.get('_Alias');
  const modeData = alias.modes.Style;
  const typography = modeData.Typography;
  const colors = modeData.Colors;

  const lines = [HEADER, ':root {\n'];
  let count = 0;

  // Font Families (4)
  lines.push('  /* ═══ Typography: Font Families ═══ */\n');
  const fontFamilies = typography['Font-Family'];
  for (const [key, node] of Object.entries(fontFamilies)) {
    if (key.startsWith('$')) continue;
    const semanticName = FONT_FAMILY_ALIAS_MAP[key];
    if (!semanticName) {
      console.warn(`Unknown font family alias: ${key}`);
      continue;
    }
    // Resolve to primitive font name
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const primitivePropName = `--primitive-font-${toKebab(resolvedValue)}`;
    lines.push(`  --alias-font-${semanticName}: var(${primitivePropName});\n`);
    count++;
  }

  // Font Styles (weights) — direct values, not references
  lines.push('\n  /* ═══ Typography: Font Styles (weights) ═══ */\n');
  const fontStyles = typography['Font-Style'];
  for (const [category, group] of Object.entries(fontStyles)) {
    if (category.startsWith('$')) continue;
    for (const [name, node] of Object.entries(group)) {
      if (name.startsWith('$')) continue;
      const weight = FONT_WEIGHT_MAP[node.$value] || 400;
      const cssName = toKebab(node.$value);
      lines.push(`  --alias-font-style-${cssName}: ${weight};\n`);
      count++;
    }
  }

  // Font Sizes (14)
  lines.push('\n  /* ═══ Typography: Font Sizes ═══ */\n');
  const fontSizes = typography['Font-Size'];
  for (const [group, sizes] of Object.entries(fontSizes)) {
    if (group.startsWith('$')) continue;
    for (const [size, node] of Object.entries(sizes)) {
      if (size.startsWith('$')) continue;
      const resolvedPx = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
      const primitiveProp = `--primitive-type-scale-${resolvedPx}`;
      lines.push(`  --alias-font-size-${toKebab(group)}-${toKebab(size)}: var(${primitiveProp});\n`);
      count++;
    }
  }

  // Line Heights (14)
  lines.push('\n  /* ═══ Typography: Line Heights ═══ */\n');
  const lineHeights = typography['Line-Height'];
  for (const [group, sizes] of Object.entries(lineHeights)) {
    if (group.startsWith('$')) continue;
    for (const [size, node] of Object.entries(sizes)) {
      if (size.startsWith('$')) continue;
      const resolvedPx = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
      const primitiveProp = `--primitive-type-scale-${resolvedPx}`;
      lines.push(`  --alias-line-height-${toKebab(group)}-${toKebab(size)}: var(${primitiveProp});\n`);
      count++;
    }
  }

  // Letter Spacing (13)
  lines.push('\n  /* ═══ Typography: Letter Spacing ═══ */\n');
  const letterSpacing = typography['Letter-Spacing'];
  for (const [name, node] of Object.entries(letterSpacing)) {
    if (name.startsWith('$')) continue;
    // Names like "LeSp+10", "LeS+4", "LeS-0 - default"
    // Resolve to primitive reference
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    // Determine sign from the primitive value
    let primitiveProp;
    if (typeof resolvedValue === 'number') {
      if (resolvedValue === 0) primitiveProp = '--primitive-letter-spacing-0';
      else if (resolvedValue > 0) primitiveProp = `--primitive-letter-spacing-pos-${Math.round(resolvedValue * 10)}`;
      else primitiveProp = `--primitive-letter-spacing-neg-${Math.abs(Math.round(resolvedValue * 10))}`;
    } else {
      primitiveProp = `--primitive-letter-spacing-0`;
    }

    // Determine alias name from Figma key
    let aliasName;
    if (name.includes('-0') || name.includes('default')) {
      aliasName = '0';
    } else {
      // Extract sign and number from names like "LeSp+10", "LeS+4", "LeS-8"
      const match = name.match(/([+-])(\d+)/);
      if (match) {
        aliasName = match[1] === '+' ? `pos-${match[2]}` : `neg-${match[2]}`;
      } else {
        aliasName = toKebab(name);
      }
    }

    lines.push(`  --alias-letter-spacing-${aliasName}: var(${primitiveProp});\n`);
    count++;
  }

  // Paragraph Spacing — excluded from CSS output (comment only)
  lines.push('\n  /* ═══ Typography: Paragraph Spacing — NOT output to CSS ═══ */\n');
  lines.push('  /* Paragraph spacing is handled by component margins, not custom properties */\n');

  // Colors
  if (colors) {
    lines.push('\n  /* ═══ Colors ═══ */\n');
    const colorEntries = flattenTree(colors);
    for (const { path, node } of colorEntries) {
      // path: ["Brand", "500"] or ["System", "Error", "500"]
      let cssName;
      if (path[0] === 'Brand') {
        cssName = `--alias-brand-${path.slice(1).map(p => toKebab(p)).join('-')}`;
      } else if (path[0] === 'System') {
        // System/Error/500 → --alias-error-500
        cssName = `--alias-${path.slice(1).map(p => toKebab(p)).join('-')}`;
      } else {
        cssName = `--alias-color-${path.map(p => toKebab(p)).join('-')}`;
      }

      // Resolve to primitive var() reference
      const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
      // Build primitive property name from resolved path
      let primitiveRef;
      if (typeof node.$value === 'string' && node.$value.startsWith('{')) {
        // It's a reference — build var() from the reference path
        const refPath = node.$value.slice(1, -1); // e.g. "Colors.ONEMO - UI Palette.Dusty.Blue Green.500"
        primitiveRef = buildPrimitiveRefFromPath(refPath, node.$collectionName);
      } else {
        primitiveRef = resolvedValue;
      }

      lines.push(`  ${cssName}: var(${primitiveRef});\n`);
      count++;
    }
  }

  lines.push('}\n');
  return { css: lines.join(''), count };
}

/**
 * Build a primitive CSS variable name from a Figma reference path
 * e.g. "Colors.ONEMO - UI Palette.Dusty.Blue Green.500" → "--primitive-color-blue-green-500"
 */
function buildPrimitiveRefFromPath(refPath, collectionName) {
  const parts = refPath.split('.');

  if (parts[0] === 'Colors') {
    // Filter out intermediate groups, including "Neutral"
    const filtered = parts.slice(1).filter(p =>
      p !== 'ONEMO - UI Palette' && p !== 'Dusty' && p !== 'Neutral'
    );
    // Use toKebabPreserveMode to preserve Gray light/dark distinction
    return `--primitive-color-${filtered.map(p => toKebabPreserveMode(p)).join('-')}`;
  }

  if (parts[0] === 'Dimensions') {
    return `--primitive-dimension-${toKebab(parts[1])}`;
  }

  if (parts[0] === 'Typography') {
    if (parts[1] === 'Type Scale') return `--primitive-type-scale-${parts[2]}`;
    if (parts[1] === 'Font Family') return `--primitive-font-${toKebab(parts[parts.length - 1])}`;
    if (parts[1] === 'Letter Spacing') {
      const rawName = parts[2];
      if (rawName === 'zero') return '--primitive-letter-spacing-0';
      if (rawName.startsWith('+')) return `--primitive-letter-spacing-pos-${rawName.slice(1)}`;
      if (rawName.startsWith('-')) return `--primitive-letter-spacing-neg-${rawName.slice(1)}`;
    }
  }

  // Fallback
  return `--primitive-${parts.map(p => toKebab(p)).join('-')}`;
}

// ─── CSS Generation: Semantic (mode-independent) ────────────────────────────

function generateSemanticCSS(collections) {
  const lines = [HEADER, '@theme {\n'];
  let count = 0;

  // Font Families (4)
  lines.push('  /* ═══ Font Families ═══ */\n');
  for (const [alias, name] of Object.entries(FONT_FAMILY_ALIAS_MAP)) {
    lines.push(`  --font-${name}: var(--alias-font-${name});\n`);
    count++;
  }

  // Spacing (17)
  lines.push('\n  /* ═══ Spacing ═══ */\n');
  const spacing = collections.get('3. Spacing');
  const spacingMode = spacing.modes['Mode 1'];
  for (const [key, node] of Object.entries(spacingMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const cssValue = typeof resolvedValue === 'number'
      ? (resolvedValue === 0 ? '0px' : pxToRem(resolvedValue))
      : `${resolvedValue}`;
    lines.push(`  --${key}: ${cssValue};\n`);
    count++;
  }

  // Radius (11)
  lines.push('\n  /* ═══ Radius ═══ */\n');
  const radius = collections.get('2. Radius');
  const radiusMode = radius.modes['Mode 1'];
  for (const [key, node] of Object.entries(radiusMode)) {
    if (key.startsWith('$')) continue;
    const value = node.$value;
    // Radius stays in px (per 11.8 decision)
    const cssValue = typeof value === 'number' ? `${value}px` : `${value}`;
    lines.push(`  --${key}: ${cssValue};\n`);
    count++;
  }

  // Widths (12) — under --spacing-* namespace for Tailwind utility generation
  lines.push('\n  /* ═══ Widths ═══ */\n');
  const widths = collections.get('4. Widths');
  const widthsMode = widths.modes['Mode 1'];
  for (const [key, node] of Object.entries(widthsMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const pxValue = typeof resolvedValue === 'number' ? resolvedValue : parseInt(resolvedValue, 10);
    // Widths stay in px (viewport-relative)
    lines.push(`  --spacing-${key}: ${pxValue}px;\n`);
    count++;
  }

  // Containers (3) — under --spacing-* namespace
  lines.push('\n  /* ═══ Containers ═══ */\n');
  const containers = collections.get('5. Containers');
  const containersMode = containers.modes.Value;
  for (const [key, node] of Object.entries(containersMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const pxValue = typeof resolvedValue === 'number' ? resolvedValue : parseInt(resolvedValue, 10);
    // Container padding → rem, max-width → px
    if (key.includes('padding')) {
      lines.push(`  --spacing-${key}: ${pxToRem(pxValue)};\n`);
    } else {
      lines.push(`  --spacing-${key}: ${pxValue}px;\n`);
    }
    count++;
  }

  // Breakpoints (derived from widths)
  lines.push('\n  /* ═══ Breakpoints ═══ */\n');
  const breakpointMap = {
    'sm': 480, 'md': 640, 'lg': 768,
    'xl': 1024, '2xl': 1280, '3xl': 1440,
  };
  for (const [name, value] of Object.entries(breakpointMap)) {
    lines.push(`  --breakpoint-${name}: ${value}px;\n`);
    count++;
  }

  // Typography Composites (26 presets × 4 sub-properties each)
  lines.push('\n  /* ═══ Typography Composites ═══ */\n');
  const typoCount = generateTypographyComposites(collections, lines);
  count += typoCount;

  lines.push('}\n');
  return { css: lines.join(''), count };
}

/**
 * Generate typography composite CSS from the 6. Typography collection
 * Returns count of tokens generated
 */
function generateTypographyComposites(collections, lines) {
  const typography = collections.get('6. Typography');
  const modeData = typography.modes.Value;
  let count = 0;

  // Walk the typography tree: Category / Variant / Size / Property
  for (const [category, variants] of Object.entries(modeData)) {
    if (category.startsWith('$')) continue;

    for (const [variant, sizes] of Object.entries(variants)) {
      if (variant.startsWith('$')) continue;

      // Check if this level has properties directly (e.g., Title/Headline has no Size sublevel)
      if (sizes.Font || sizes.Style || sizes.Size) {
        // Direct preset (no size sublevel) — e.g., Title/Headline
        const preset = sizes;
        const presetName = `${toKebab(category)}-${toKebab(variant)}`;
        count += emitPreset(presetName, preset, category, variant, null, collections, lines);
        continue;
      }

      for (const [size, preset] of Object.entries(sizes)) {
        if (size.startsWith('$')) continue;

        if (!preset.Font && !preset.Style && !preset.Size) {
          // Still nested — one more level (e.g., Display/Brand Deco/2XL)
          // This shouldn't happen based on the data, but handle it
          continue;
        }

        const presetName = `${toKebab(category)}-${toKebab(variant)}-${toKebab(size)}`;
        count += emitPreset(presetName, preset, category, variant, size, collections, lines);
      }
    }
  }

  return count;
}

function emitPreset(presetName, preset, category, variant, size, collections, lines) {
  let count = 0;

  // Resolve Size → font-size in rem
  if (preset.Size) {
    const sizeVal = resolveReference(preset.Size.$value, preset.Size.$collectionName || '_Alias', collections);
    const sizeRem = typeof sizeVal === 'number' ? pxToRem(sizeVal) : sizeVal;
    lines.push(`  --text-${presetName}: ${sizeRem};\n`);
    count++;
  }

  // Resolve Line → line-height in rem
  if (preset.Line) {
    const lineVal = resolveReference(preset.Line.$value, preset.Line.$collectionName || '_Alias', collections);
    const lineRem = typeof lineVal === 'number' ? pxToRem(lineVal) : lineVal;
    lines.push(`  --text-${presetName}--line-height: ${lineRem};\n`);
    count++;
  }

  // Resolve Letter → letter-spacing in em
  if (preset.Letter) {
    const letterVal = resolveReference(preset.Letter.$value, preset.Letter.$collectionName || '_Alias', collections);
    const letterEm = typeof letterVal === 'number' ? letterSpacingToEm(letterVal) : letterVal;
    lines.push(`  --text-${presetName}--letter-spacing: ${letterEm};\n`);
    count++;
  }

  // Resolve Style → font-weight
  if (preset.Style) {
    const styleVal = resolveReference(preset.Style.$value, preset.Style.$collectionName || '_Alias', collections);
    const weight = FONT_WEIGHT_MAP[styleVal] || 400;
    lines.push(`  --text-${presetName}--font-weight: ${weight};\n`);
    count++;
  }

  lines.push('\n');
  return count;
}

// ─── CSS Generation: Semantic Inline (mode-dependent colors) ────────────────

function generateSemanticInlineCSS(collections) {
  const colorModes = collections.get('1. Color modes');
  const lightMode = colorModes.modes['Light mode'];
  const darkMode = colorModes.modes['Dark mode'];

  const lightEntries = flattenTree(lightMode);
  const darkEntries = flattenTree(darkMode);

  // Build dark mode lookup
  const darkMap = new Map();
  for (const entry of darkEntries) {
    const key = entry.path.join('.');
    darkMap.set(key, entry);
  }

  const lines = [HEADER];
  let count = 0;

  // Section 1: Light mode defaults in :root
  lines.push('/* ═══ Light mode defaults ═══ */\n:root {\n');

  for (const { path, node } of lightEntries) {
    const semanticName = buildSemanticColorName(path);
    const cssRef = buildColorValueRef(node, collections, 'light');
    lines.push(`  --semantic-${semanticName}: ${cssRef};\n`);
    count++;
  }

  lines.push('}\n\n');

  // Section 2: Dark mode overrides
  lines.push('/* ═══ Dark mode overrides ═══ */\n[data-theme="dark"] {\n');

  for (const { path, node } of darkEntries) {
    const semanticName = buildSemanticColorName(path);
    const cssRef = buildColorValueRef(node, collections, 'dark');
    lines.push(`  --semantic-${semanticName}: ${cssRef};\n`);
  }

  lines.push('}\n\n');

  // Section 3: Register for Tailwind utilities
  lines.push('/* ═══ Tailwind theme registration ═══ */\n@theme inline {\n');

  for (const { path } of lightEntries) {
    const semanticName = buildSemanticColorName(path);
    lines.push(`  --color-${semanticName}: var(--semantic-${semanticName});\n`);
  }

  lines.push('}\n');

  return { css: lines.join(''), count };
}

/**
 * Build semantic color name from path
 * e.g. ["Colors", "Text", "text-primary (900)"] → "text-primary"
 * e.g. ["Colors", "Background", "bg-primary_hover"] → "bg-primary-hover"
 * e.g. ["Component colors", "Alpha", "alpha-white-50"] → "alpha-white-50"
 */
function buildSemanticColorName(path) {
  // The last segment is the actual token name
  const tokenName = path[path.length - 1];
  return toKebab(tokenName);
}

/**
 * Build a CSS var() reference for a color mode token value
 */
function buildColorValueRef(node, collections, mode) {
  const value = node.$value;

  // Literal value (rgba, hex)
  if (typeof value !== 'string' || !value.startsWith('{')) {
    return value;
  }

  const collectionName = node.$collectionName;
  const refPath = value.slice(1, -1);

  // Self-reference within Color modes collection
  if (collectionName === '1. Color modes') {
    // Reference to another semantic token — output as var(--semantic-*)
    const parts = refPath.split('.');
    const tokenName = parts[parts.length - 1];
    return `var(--semantic-${toKebab(tokenName)})`;
  }

  // Reference to _Alias
  if (collectionName === '_Alias') {
    const refProp = buildAliasRefFromPath(refPath);
    return `var(${refProp})`;
  }

  // Reference to _Primitives
  if (collectionName === '_Primitives') {
    const refProp = buildPrimitiveRefFromPath(refPath, collectionName);
    return `var(${refProp})`;
  }

  // Fallback: resolve to literal
  const resolved = resolveReference(value, collectionName, collections);
  return typeof resolved === 'string' ? resolved : `${resolved}`;
}

/**
 * Build an alias CSS variable name from a reference path
 * e.g. "Colors.Brand.200" → "--alias-brand-200"
 * e.g. "Colors.System.Error.500" → "--alias-error-500"
 */
function buildAliasRefFromPath(refPath) {
  const parts = refPath.split('.');

  if (parts[0] === 'Colors') {
    if (parts[1] === 'Brand') {
      return `--alias-brand-${parts.slice(2).map(p => toKebab(p)).join('-')}`;
    }
    if (parts[1] === 'System') {
      return `--alias-${parts.slice(2).map(p => toKebab(p)).join('-')}`;
    }
  }

  // Typography aliases
  if (parts[0] === 'Typography') {
    if (parts[1] === 'Font-Family') {
      const key = parts[2];
      const name = FONT_FAMILY_ALIAS_MAP[key];
      return name ? `--alias-font-${name}` : `--alias-font-${toKebab(key)}`;
    }
  }

  return `--alias-${parts.map(p => toKebab(p)).join('-')}`;
}

// ─── Token Reference Generator ──────────────────────────────────────────────

function generateTokenReference(collections) {
  const lines = [
    '# 11.9 Token Reference\n\n',
    '> Machine-readable token listing for AI agents. Prevents hard-coding hex values.\n',
    '> Auto-generated by `node scripts/build-tokens.mjs`.\n\n',
    '**DO NOT EDIT** — regenerate from the Figma JSON export.\n\n',
    '---\n\n',
  ];

  // Spacing tokens
  lines.push('## Spacing Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Value |\n');
  lines.push('|---|---|---|\n');
  const spacing = collections.get('3. Spacing');
  const spacingMode = spacing.modes['Mode 1'];
  for (const [key, node] of Object.entries(spacingMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const cssValue = typeof resolvedValue === 'number'
      ? (resolvedValue === 0 ? '0px' : pxToRem(resolvedValue))
      : `${resolvedValue}`;
    lines.push(`| \`--${key}\` | \`p-${key.replace('spacing-', '')}\`, \`m-${key.replace('spacing-', '')}\`, \`gap-${key.replace('spacing-', '')}\` | \`${cssValue}\` |\n`);
  }

  // Radius tokens
  lines.push('\n## Radius Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Value |\n');
  lines.push('|---|---|---|\n');
  const radius = collections.get('2. Radius');
  const radiusMode = radius.modes['Mode 1'];
  for (const [key, node] of Object.entries(radiusMode)) {
    if (key.startsWith('$')) continue;
    lines.push(`| \`--${key}\` | \`rounded-${key.replace('radius-', '')}\` | \`${node.$value}px\` |\n`);
  }

  // Font slots
  lines.push('\n## Font Family Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Font |\n');
  lines.push('|---|---|---|\n');
  for (const [alias, name] of Object.entries(FONT_FAMILY_ALIAS_MAP)) {
    lines.push(`| \`--font-${name}\` | \`font-${name}\` | ${alias} |\n`);
  }

  // Color tokens (semantic)
  lines.push('\n## Color Tokens (Semantic)\n\n');
  lines.push('Use these — never hard-code hex values.\n\n');
  lines.push('| CSS Property | Tailwind Class | Category |\n');
  lines.push('|---|---|---|\n');

  const colorModes = collections.get('1. Color modes');
  const lightEntries = flattenTree(colorModes.modes['Light mode']);
  for (const { path } of lightEntries) {
    const name = buildSemanticColorName(path);
    const category = path.length > 1 ? path[1] || path[0] : path[0];
    // Determine which Tailwind prefix applies
    let twClass;
    if (name.startsWith('text-')) twClass = `text-${name}`;
    else if (name.startsWith('bg-')) twClass = `bg-${name}`;
    else if (name.startsWith('fg-')) twClass = `text-${name}`;
    else if (name.startsWith('border-')) twClass = `border-${name}`;
    else if (name.startsWith('focus-')) twClass = `ring-${name}`;
    else if (name.startsWith('shadow-')) twClass = `shadow-(--color-${name})`;
    else twClass = `bg-${name}`;

    lines.push(`| \`--color-${name}\` | \`${twClass}\` | ${toKebab(category)} |\n`);
  }

  // Typography composites
  lines.push('\n## Typography Composite Tokens\n\n');
  lines.push('Each `text-*` utility applies font-size, line-height, letter-spacing, and font-weight.\n');
  lines.push('Pair with a `font-*` utility for the font family.\n\n');
  lines.push('| Tailwind Class | Font-Size | Line-Height | Letter-Spacing | Font-Weight | Font Class |\n');
  lines.push('|---|---|---|---|---|---|\n');

  const typo = collections.get('6. Typography');
  const typoMode = typo.modes.Value;

  for (const [category, variants] of Object.entries(typoMode)) {
    if (category.startsWith('$')) continue;
    for (const [variant, sizes] of Object.entries(variants)) {
      if (variant.startsWith('$')) continue;

      // Direct preset (no size level)
      if (sizes.Font || sizes.Style || sizes.Size) {
        const preset = sizes;
        const presetName = `${toKebab(category)}-${toKebab(variant)}`;
        emitPresetReference(presetName, preset, collections, lines);
        continue;
      }

      for (const [size, preset] of Object.entries(sizes)) {
        if (size.startsWith('$')) continue;
        if (!preset.Font && !preset.Style && !preset.Size) continue;
        const presetName = `${toKebab(category)}-${toKebab(variant)}-${toKebab(size)}`;
        emitPresetReference(presetName, preset, collections, lines);
      }
    }
  }

  // Width tokens
  lines.push('\n## Width Tokens\n\n');
  lines.push('| CSS Property | Tailwind Utility | Value |\n');
  lines.push('|---|---|---|\n');
  const widths = collections.get('4. Widths');
  const widthsMode = widths.modes['Mode 1'];
  for (const [key, node] of Object.entries(widthsMode)) {
    if (key.startsWith('$')) continue;
    const resolvedValue = resolveReference(node.$value, node.$collectionName || '_Primitives', collections);
    const pxValue = typeof resolvedValue === 'number' ? resolvedValue : parseInt(resolvedValue, 10);
    lines.push(`| \`--spacing-${key}\` | \`w-${key}\` | \`${pxValue}px\` |\n`);
  }

  // Breakpoints
  lines.push('\n## Breakpoints\n\n');
  lines.push('| CSS Property | Responsive Prefix | Value |\n');
  lines.push('|---|---|---|\n');
  const breakpointMap = {
    'sm': 480, 'md': 640, 'lg': 768,
    'xl': 1024, '2xl': 1280, '3xl': 1440,
  };
  for (const [name, value] of Object.entries(breakpointMap)) {
    lines.push(`| \`--breakpoint-${name}\` | \`${name}:\` | \`${value}px\` |\n`);
  }

  return lines.join('');
}

function emitPresetReference(presetName, preset, collections, lines) {
  const sizeVal = preset.Size
    ? resolveReference(preset.Size.$value, preset.Size.$collectionName || '_Alias', collections)
    : '?';
  const lineVal = preset.Line
    ? resolveReference(preset.Line.$value, preset.Line.$collectionName || '_Alias', collections)
    : '?';
  const letterVal = preset.Letter
    ? resolveReference(preset.Letter.$value, preset.Letter.$collectionName || '_Alias', collections)
    : 0;
  const styleVal = preset.Style
    ? resolveReference(preset.Style.$value, preset.Style.$collectionName || '_Alias', collections)
    : 'Regular';

  const fontRef = preset.Font
    ? resolveReference(preset.Font.$value, preset.Font.$collectionName || '_Alias', collections)
    : '?';

  // Determine font slot
  let fontSlot = 'font-primary';
  if (typeof fontRef === 'string') {
    const fontLower = fontRef.toLowerCase();
    if (fontLower.includes('electric') || fontLower.includes('deco')) fontSlot = 'font-display-deco';
    else if (fontLower.includes('chillax') || fontLower.includes('plain')) fontSlot = 'font-display-plain';
    else if (fontLower.includes('oxanium') || fontLower.includes('label')) fontSlot = 'font-label';
  }
  // Also check the Font reference path for alias names
  if (preset.Font && typeof preset.Font.$value === 'string') {
    const ref = preset.Font.$value;
    if (ref.includes('Secondary - Deco')) fontSlot = 'font-display-deco';
    else if (ref.includes('Secondary - Plain') || ref.includes('Secondary  - Plain')) fontSlot = 'font-display-plain';
    else if (ref.includes('Tertiary')) fontSlot = 'font-label';
    else if (ref.includes('Primary')) fontSlot = 'font-primary';
  }

  const sizeRem = typeof sizeVal === 'number' ? pxToRem(sizeVal) : sizeVal;
  const lineRem = typeof lineVal === 'number' ? pxToRem(lineVal) : lineVal;
  const letterEm = typeof letterVal === 'number' ? letterSpacingToEm(letterVal) : letterVal;
  const weight = FONT_WEIGHT_MAP[styleVal] || 400;

  lines.push(`| \`text-${presetName}\` | ${sizeRem} | ${lineRem} | ${letterEm} | ${weight} | \`${fontSlot}\` |\n`);
}

// ─── Main ────────────────────────────────────────────────────────────────────

async function main() {
  const jsonPath = process.argv[2] || DEFAULT_JSON;

  console.log('╔══════════════════════════════════════════════╗');
  console.log('║  ONEMO Design Token Pipeline — build-tokens  ║');
  console.log('╚══════════════════════════════════════════════╝');
  console.log(`\nSource: ${jsonPath}`);
  console.log(`Output: ${OUTPUT_DIR}/\n`);

  // Read and parse JSON
  const raw = await readFile(jsonPath, 'utf-8');
  const json = JSON.parse(raw);
  const collections = parseCollections(json);

  console.log(`Collections found: ${[...collections.keys()].join(', ')}\n`);

  // Ensure output directory exists
  await mkdir(OUTPUT_DIR, { recursive: true });

  // Generate CSS files
  const primitives = generatePrimitivesCSS(collections);
  const aliases = generateAliasesCSS(collections);
  const semantic = generateSemanticCSS(collections);
  const semanticInline = generateSemanticInlineCSS(collections);

  // Write CSS files
  await writeFile(join(OUTPUT_DIR, 'primitives.css'), primitives.css);
  await writeFile(join(OUTPUT_DIR, 'aliases.css'), aliases.css);
  await writeFile(join(OUTPUT_DIR, 'semantic.css'), semantic.css);
  await writeFile(join(OUTPUT_DIR, 'semantic-inline.css'), semanticInline.css);

  // Generate and write token reference
  const tokenRef = generateTokenReference(collections);
  const ssotDir = join(ROOT, '..', 'onemo-ssot-global', '11-design-system');
  await writeFile(join(ssotDir, '11.9-token-reference.md'), tokenRef);

  // Summary
  console.log('─── Generated Files ───');
  console.log(`  primitives.css:       ${primitives.count} tokens`);
  console.log(`  aliases.css:          ${aliases.count} tokens`);
  console.log(`  semantic.css:         ${semantic.count} tokens`);
  console.log(`  semantic-inline.css:  ${semanticInline.count} tokens (×3 sections)`);
  console.log(`  11.9-token-reference.md: written to SSOT`);
  console.log(`\nTotal: ${primitives.count + aliases.count + semantic.count + semanticInline.count} CSS custom properties\n`);
  console.log('✅ Done. Run `npm run dev` to verify.\n');
}

main().catch(err => {
  console.error('❌ Build failed:', err.message);
  process.exit(1);
});
